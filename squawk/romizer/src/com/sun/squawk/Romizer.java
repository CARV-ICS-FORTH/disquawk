/*
 * Copyright 2004-2010 Sun Microsystems, Inc. All Rights Reserved.
 * Copyright 2011 Oracle Corporation. All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER
 *
 * This code is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2
 * only, as published by the Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License version 2 for more details (a copy is
 * included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License
 * version 2 along with this work; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *
 * Please contact Oracle Corporation, 500 Oracle Parkway, Redwood
 * Shores, CA 94065 or visit www.oracle.com if you need additional
 * information or have any questions.
 */

package com.sun.squawk;

import java.io.*;
import java.util.*;
import java.util.Arrays;
import java.util.jar.*;
import java.util.zip.*;
import javax.microedition.io.*;

import com.sun.squawk.util.*;
import com.sun.squawk.translator.*;
import com.sun.squawk.translator.ir.InstructionEmitter;
import com.sun.squawk.io.connections.ClasspathConnection;

/**
 * The romizer statically executes the translator over a set of classes
 * that are to be romized and then transfers the romized classes
 * from the host JVM's memory to an image file.
 */
public class Romizer {

    /**
     * The "build.properties" file.
     */
    protected static Properties buildProperties;

    private static String buildDotOverrideFileName;

    static String getBuildProperty(String key) {
        if (buildProperties == null) {
            initBuildProperties();
        }
        String result = buildProperties.getProperty(key);
        if (result == null) {
            throw new RuntimeException("Property " + key + " is undefined");
        }
        return result;
    }

    /**
     * Reads the contents of the build properties.
     */
    protected static void initBuildProperties() {
        buildProperties = new Properties();
        FileInputStream inputStream = null;
        try {
            inputStream = new FileInputStream("build.properties");
            buildProperties.load(inputStream);
        } catch(IOException ex) {
            throw new Error("Could not find build.properties");
        } finally {
            if (inputStream != null) {
                try {inputStream.close();} catch (IOException e) {}
                inputStream = null;
            }
        }
        try {
            if (buildDotOverrideFileName == null) {
                buildDotOverrideFileName = "build.override";
            }
            File overideProperties = new File(buildDotOverrideFileName);
            if (overideProperties.exists()) {

                // Make it very clear to the user which properties in the standard properties
                // file are potentially being overridden
                System.out.println(">>>>>>>>>>>>>>>>>>>>>>>>>>>>>> Using build override file: " + overideProperties.getPath() + " <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<");
                inputStream = new FileInputStream(overideProperties);
                buildProperties.load(inputStream);
            }
        } catch (IOException ex) {
        } finally {
            if (inputStream != null) {
                try {inputStream.close();} catch (IOException e) {}
                inputStream = null;
            }
        }
    }

    static void putBuildProperty(String key, String value) {
        if (buildProperties == null) {
            initBuildProperties();
        }
        buildProperties.put(key, value);
    }

    /**
     * The name of the suite being romized (the full name)
     */
    private String suiteName;

    /**
     * The suite being romized.
     */
    private Suite suite;

    /**
     * The search path for classes in the suite.
     */
    private String classPath;

    /**
     * The search path for classes in the suite, but with Java 5 meta data still present.
     */
    private String java5ClassPath;

    /**
     * The Romizer instance from a failed romize attaemp that preceeded the current romize attempt.
     */
    private Romizer previous;

    /**
     * The files generated by the romizer.
     */
    private Vector<String> generatedFiles = new Vector<String>();

    /**
     * Type of suite to create. This controls how much of the symbolic information is retained
     * in the suite when it is closed.
     */
    private int suiteType;

    /**
     * The class name patterns to be excluded as defined in an excludes files.
     */
    private Vector<String> excludes;

    /**
     * Specifies if the _classes.jar and _rt.jar files should be created.
     */
    private boolean createJars;

    /**
     * Specifies if the .suite.metadata file will be created.
     */
    private boolean createMetadata = true;

    /**
     * Specifies if the timing information should be displayed.
     */
    private static boolean timer;

/*if[J2ME.STATS]*/
    /**
     * Specifies if translation statistics should be gathered and printed.
     */
    private static boolean stats = false;
/*end[J2ME.STATS]*/

    /**
     * This is a prototype translator used to process and print translator options. It is not the translator used for translation.
     */
    private TranslatorInterface protoTranslator;

    /**
     * Holds the name of the class that caused the last NoClassDefFoundError.
     */
    protected String lastClassName;

    protected List<String> noClassDefFoundErrorClasses = new ArrayList<String>();

    protected HashMap<String, String> jadProperties = new HashMap<String, String>();

    /**
     * This is the ObjectGraphLoader used when the -parent: option is used to specify the suite to load
     */
    protected ObjectGraphLoader objectGraphLoader;

    /**
     * If true, do not create the C header "rom.h"
     */
    private boolean noHeader;

    /**
     * Creates the romizer instance used to romize a suite.
     *
     * @param parent  the romizer that was used to romize the parent suite
     *                or null if this is the romizer creating the bootstrap suite
     */
    private Romizer(Romizer previous) {
        if (previous != null) {
            suiteType = previous.suiteType;
            this.previous = previous;
        } else {
            suiteType = Suite.LIBRARY;
        }
        protoTranslator = new Translator();
        objectGraphLoader = new ObjectGraphLoader();
    }


    /**
     * Prints the usage message.
     *
     * @param  errMsg  an optional error message
     */
    private void usage(String errMsg) {
        PrintStream out = System.out;
        if (errMsg != null) {
            out.println("**** " + errMsg + " ****");
        }

        out.println("Usage: romize [-options] classnames|dirnames|jarfiles...");
        out.println("where options include:");
        out.println();
        out.println("    -cp:<directories and jar/zip files separated by '"+File.pathSeparatorChar+"'>");
        out.println("                        paths where classes and sources can be found (required)");
        out.println("    -suitepath:<directories separated by '"+File.pathSeparatorChar+"'>");
        out.println("                        path where suite files can be found");
        out.println("    -o:<name>           name of suite to generate (required)");
        out.println("    -boot:<name>        name of suite to to use for references to " + ObjectMemory.BOOTSTRAP_URI + " suite URL (default=file://squawk.suite)");
        out.println("    -parent:<name>      name of suite to use as the parent of the suite being built");
        out.println("    -metadata           create matching metadata suite (default)");
        out.println("    -nometadata         do not create matching metadata suite");
        out.println("    -header             do not create C header file rom.h");
        out.println("    -jars               create <suite_name>_classes.jar which contains the class files");
        out.println("                        from which the suite was built");
        out.println("    -exclude:<file>     excludes classes that match the class names or packages");
        out.println("                        in file ('<name>.exclude' is used implicitly)");
        out.println("    -noclassdeffounderrorclass:<class name>    This class should cause a NoClassDefFoundError at runtime");
        out.println("    -endian:<value>     endianess ('big' or 'little') for generated suite (required)");
        out.println("    -arch:<name>        base name for dynamic compiler. Full name will be");
        out.println("                        \"com.sun.squawk.compiler.<name>Compiler\"");
        out.println("    -override:<file>     file to use to override the build.properties file found locally, defaults to build.override");
        out.println("    -nobuildproperties   do not load build.propeties");
        protoTranslator.printOptionProperties(out, true);
        out.println("    -strip:<t>          strip symbolic information according to <t>:");
        out.println("                           'd' - debug: retain all symbolic info");
        out.println("                           'a' - application: discard all symbolic info");
        out.println("                           'l' - library (default): discard symbolic info");
        out.println("                                 for private/package-private fields and methods");
        out.println("                           'e' - extendable library: discard symbolic info");
        out.println("                                 for private fields and methods");
        out.println("    -lnt                retain line number tables");
        out.println("    -lvt                retain local variable tables");
        out.println("    -timer              print various phase timing statistics");
        out.println("    -verbose, -v        provide more output while running");
        out.println("    -stats              print various translation statistics");
        out.println("    -key:<name>         set key to add to suite's JAD properties");
        out.println("                        must be followed by -value: option");
        out.println("    -value:<name>       set value to add to suite's JAD properties");
        out.println("                        must be preceded by -key: option");

        protoTranslator.printTraceFlags(out);

        if (Klass.TRACING_ENABLED) {
            out.println("    -tracestripping     trace stripping of symbolic information from suite");
            out.println("    -traceoms           trace object memory serialization");
            out.println("    -traceswapper       trace endianess swapping");
        }

        out.println("    -h                  show this help message and exit");
        out.println();
        out.println();
        out.println("More than one suite can be created by separating the arguments for each");
        out.println("suite with '--'. For example:");
        out.println();
        out.println("  romize -o:squawk -cp:cldc/j2meclasses cldc/j2meclasses -- -cp:translator/j2meclasses -o:translator translator/j2meclasses");
        out.println();
    }

    /**
     * Processes a file with specifications of classes to exclude from the romizing process.
     * Each line in the file may be guarded with a property whose value is determined from
     * 'build.properties'.
     *
     * @param file     the file of exclude specifications
     * @return the read in specifications
     */
    private static Vector<String> readExcludesFile(String file) {
        Vector<String> lines = new Vector<String>();
        System.out.println("Loaded class excludes list from " + file);
        LineReader.readLines(file, lines);

        Vector<String> excludes = new Vector<String>(lines.size());
        for (String line : lines) {
            line = line.trim();
            if (line.length() == 0 || line.startsWith("#")) {
                continue;
            }
            int index = line.indexOf(' ');
            if (index != -1) {
                // This is an exclusion predicated on a build property
                String predicate = line.substring(0, index);
                line = line.substring(index+1);
                String value = "false"; // The default value where there is not '='.
                index = predicate.indexOf('=');
                boolean doNotOfPredicate = false;

                if (index != -1) {
                    value = predicate.substring(index+1);
                    if (predicate.indexOf("!=") == (index - 1)) {
                        index--;
                        doNotOfPredicate = true;
                    }
                    predicate = predicate.substring(0, index);
                }
                boolean predicateTrue = getBuildProperty(predicate).equals(value);
                if (doNotOfPredicate) {
                    predicateTrue = !predicateTrue;
                }
                if (!predicateTrue) {
                    continue;
                }
                while (line.charAt(0) == ' ') { // remove any extra spaces
                    line = line.substring(1);
                }
            }
            excludes.addElement(line);
		}
        return excludes;
    }

    static void traceRomize(String[] args) {
        System.out.println("Running romize with args:");
        for (String arg : args) {
            System.out.println("    " + arg);
        }
        System.out.flush();
    }

    /**
     * Command line interface.
     *
     * @param args
     * @throws IOException
     */
    public static void main(String args[]) throws IOException {
        Romizer romizer = null;
        List<String> classNames = new ArrayList<String>();
        String[] argsLeft = args;
        while (true) {
	        try {
	            String[] newArgsLeft = new String[argsLeft.length + classNames.size()];
	            System.arraycopy(argsLeft, 0, newArgsLeft, classNames.size(), argsLeft.length);
	            argsLeft = newArgsLeft;
	            int i = 0;
	            for (String className: classNames) {
	            	argsLeft[i++] = "-noclassdeffounderrorclass:" + className;
	            }
                classNames.clear();
		        while (argsLeft != null) {
		            romizer = new Romizer(romizer);
                    //traceRomize(argsLeft);
		            argsLeft = romizer.run(argsLeft);
		        }
		        return;
	        } catch (NoClassDefFoundError e) {
                if (romizer != null && romizer.getLastClassName() != null) {
	            	classNames.add(romizer.getLastClassName());
                    System.err.flush();
                    System.out.flush();
                    System.err.println("WARNING: Deferring Errors:");
                    System.err.println("   " + e.getClass().getSimpleName() + ": " + romizer.getLastClassName());
                    System.err.println("   message: " + e.getLocalizedMessage());
                    System.err.println("   possibly in class: " + romizer.getLastClassName());
                    buildProperties = null; // reset properties for next run...
                    // TODO Deal with fact that for TCK this must continue
                    e.printStackTrace();
	                continue;
                }
                throw e;
            }
        }
    }

    /**
     * Runs this instance of the romizer to produce a single suite.
     *
     * @param args  the arguments specifying the options and components of the suite
     * @return the remaining command line arguments after a "--" argument specifying subsequent suites or null
     *         if there are none
     */
    private String[] run(String[] args) {
        if (args.length == 0) {
            usage(null);
            return null;
        }
        try {
            args = ArgsUtilities.expandArgFiles(args);
            final Vector<String> classNames = new Vector<String>();
            final Vector<ResourceFile> resources = new Vector<ResourceFile>();
            args = processSuiteArgs(args, classNames, resources);
            if (args == null && suite == null) {
                return null;
            }

            // Load and translate the classes in the suite
            ComputationTimer.time("translating", new ComputationTimer.ComputationException() {
                public Object run() throws Exception {
                    translate(classNames);
                    return null;
                }
            });
            // Install resources found
            for (int i=0, maxI=resources.size(); i < maxI; i++) {
                ResourceFile resourceFile = (ResourceFile) resources.elementAt(i);
                suite.installResource(resourceFile);
            }
            // Install the jad properties passed on the command line
            for (String key: jadProperties.keySet()) {
            	String value = jadProperties.get(key);
            	suite.setProperty(key, value);
            }

            // Create the image file for the suite
            ComputationTimer.time("suite file creation", new ComputationTimer.ComputationException() {
                public Object run() throws Exception {
                    createImage();
                    return null;
                }
            });

            if (suite.getParent() == null && !noHeader) {
                // Create the header file for the C implementation of the Squawk interpreter
                ComputationTimer.time("rom header creation", new ComputationTimer.ComputationException() {
                    public Object run() throws Exception {
                        createCHeader();
                        return null;
                    }
                });
            }

            ComputationTimer.time(suiteName + ".api creation", new ComputationTimer.ComputationException() {
                public Object run() throws Exception {
                    createSuiteAPI();
                    return null;
                }
            });
            if (timer) {
                ComputationTimer.dump(System.out);
                ComputationTimer.reset();
            }

        } catch (Exception e) {
            e.printStackTrace();
            throw new RuntimeException(e);
        }

/*if[J2ME.STATS]*/
        if (stats) {
/*if[DEBUG_CODE_ENABLED]*/
            KlassMetadata.Debug.printStats(System.out);
/*end[DEBUG_CODE_ENABLED]*/
            com.sun.squawk.translator.ir.InstructionEmitter.printStats();
        }
/*end[J2ME.STATS]*/

        System.out.print("Romizer processed " + suite.getClassCount() + " classes and generated " + generatedFiles.size() + " files");
        if (VM.isVerbose()) {
            System.out.println(":");
            for (String name : generatedFiles) {
                System.out.println("  " + name);
            }
        } else {
            System.out.println(".");
        }

        return args;
    }

    /**
     * Parses and processes a given set of command line arguments to translate a single suite.
     *
     * @param   args        the command line arguments
     * @param   classNames  a vector to collect the names of the classes to be translated
     * @param   Vector<ResourceFile> resources  a vector to collect the resources to be included
     * @return  the remaining command line arguments specifying a subsequent suite or null
     * @throws RuntimeException if the arguments are malformed
     */
    private String[] processSuiteArgs(String[] args, Vector<String> classNames, Vector<ResourceFile> resources) {
        int argc = 0;
        String excludeFile = null;

        Suite parentSuite = null;
        String key = null;
        boolean userAskedForDCE = false;

        while (argc != args.length) {
            String arg = args[argc];

            if (arg == null || arg.charAt(0) != '-') {
                break;
            } else if (arg.equalsIgnoreCase("-deadClassElimination:true")) {
                userAskedForDCE = true;
            }

            if (arg.startsWith("-D")) {
                try {
                    String name = arg.substring("-D".length(), arg.indexOf('='));
                    String value = arg.substring(arg.indexOf('=') + 1);
                    putBuildProperty(name, value);
                } catch (IndexOutOfBoundsException e) {
                    usage("malformed -D option: " + arg);
                    throw new RuntimeException();
                }
            } else if (arg.startsWith("-cp:")) {
                classPath = ArgsUtilities.toPlatformPath(arg.substring("-cp:".length()), true);
            } else if (arg.startsWith("-java5cp:")) {
                java5ClassPath = ArgsUtilities.toPlatformPath(arg.substring("-java5cp:".length()), true);
            } else if (arg.startsWith("-exclude:")) {
                excludeFile = arg.substring("-exclude:".length());
            } else if (arg.startsWith("-noclassdeffounderrorclass:")) {
                noClassDefFoundErrorClasses.add(arg.substring("-noclassdeffounderrorclass:".length()));
            } else if (arg.startsWith("-o:")) {
                suiteName = arg.substring("-o:".length());
            } else if (arg.equals("-jars")) {
                createJars = true;
            } else if (arg.equals("-metadata")) {
                createMetadata = true;
            } else if (arg.equals("-nometadata")) {
                createMetadata = false;
            } else if (arg.startsWith("-endian:")) {
                String value = arg.substring("-endian:".length());
                if (value.equals("big")) {
                    VM.setIsBigEndian(true);
                } else if (value.equals("little")) {
                     VM.setIsBigEndian(false);
                } else {
                    usage("invalid endianess: " + value);
                    throw new RuntimeException();
                }
            } else if (arg.startsWith("-arch:")) {
                String arch = arg.substring("-arch:".length()).toUpperCase();
                putBuildProperty("ARCHITECTURE", arch);
            } else if (arg.startsWith("-strip:") || arg.startsWith("-prune:")) {
                char type = arg.substring("-strip:".length()).charAt(0);
                if (type == 'a') {
                    suiteType = Suite.APPLICATION;
                } else if (type == 'd') {
                    suiteType = Suite.DEBUG;
                } else if (type == 'l') {
                    suiteType = Suite.LIBRARY;
                } else if (type == 'e') {
                    suiteType = Suite.EXTENDABLE_LIBRARY;
                } else {
                    usage("invalid suite type: " + type);
                    throw new RuntimeException();
                }
            } else if (arg.equals("-lnt")) {
                MethodMetadata.preserveLineNumberTables();
            } else if (arg.equals("-lvt")) {
                MethodMetadata.preserveLocalVariableTables();
            } else if (arg.equals("-timer")) {
                timer = true;
            } else if (arg.equals("-stats")) {
                System.setProperty("translator.stats", "true");
/*if[J2ME.STATS]*/
                stats = true;
/*end[J2ME.STATS]*/
            } else if (arg.startsWith("-trace")) {
                if (arg.startsWith("-tracefilter:")) {
                    String optArg = arg.substring("-tracefilter:".length());
                    Tracer.setFilter(optArg);
                } else {
                    Tracer.enableFeature(arg.substring("-trace".length()));
                    if (arg.equals("-traceconverting")) {
                        Tracer.enableFeature("loading"); // -traceconverting subsumes -traceloading
                    }
                }
            } else if (arg.equals("-noheader")) {
                noHeader = true;
            } else if (arg.equals("-verbose") | arg.equals("-v")) {
                System.setProperty("translator.verbose", "true");
                VM.setVerbose(true);
            } else if (arg.startsWith("-h")) {
                usage(null);
                return null;
            } else if (arg.startsWith("-boot:")) {
                String bootSuiteName = arg.substring("-boot:".length());
                String suiteUrl = "file://" + bootSuiteName + Suite.FILE_EXTENSION;
                System.setProperty(ObjectMemory.BOOTSTRAP_URI_PROPERTY, suiteUrl);
                try {
                    parentSuite = objectGraphLoader.loadSuite(suiteUrl);
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
                System.setProperty("bootstrap.suite.url", suiteUrl);
            } else if (arg.startsWith("-parent:")) {
                String parentSuiteName = arg.substring("-parent:".length());
                String suiteUrl;
                if (false && ObjectMemoryLoader.SIGNATURE_SCHEME == ObjectMemoryLoader.CHAINED_SIGNATURE) {
                    // suites normally signed, but romizer can't handle that yet. So use unsigned suite...
                    suiteUrl = "file://unsigned-" + parentSuiteName + Suite.FILE_EXTENSION;
                } else {
                    suiteUrl = "file://" + parentSuiteName + Suite.FILE_EXTENSION;
                }
                try {
                    parentSuite = objectGraphLoader.loadSuite(suiteUrl);
                } catch (IOException e) {
                    throw new RuntimeException(e);
                }
            } else if (arg.startsWith("-suitepath:")) {
                String path = arg.substring("-suitepath:".length());
                ObjectMemoryLoader.addFilePath(path);

            } else if (arg.startsWith("-nobuildproperties")) {
                if (buildDotOverrideFileName != null) {
                    throw new RuntimeException("Can't specify both -nobuildproperties and -override:");
                }
                buildProperties = new Properties();
            } else if (arg.startsWith("-override:")) {
                if (buildProperties != null) {
                    throw new RuntimeException("Can't specify both -nobuildproperties and -override:");
                }
	        	buildDotOverrideFileName = arg.substring("-override:".length());
            } else if (arg.startsWith("-key:")) {
            	key = arg.substring("-key:".length());
            } else if (arg.startsWith("-value:")) {
            	if (key == null) {
            		throw new RuntimeException("Did not specify a key for " + arg);
            	}
            	String value = arg.substring("-key:".length());
            	jadProperties.put(key, value);
            } else if (!protoTranslator.processOption(arg)) {
                usage("Unknown option "+arg);
                throw new RuntimeException("Unknown option "+arg);
            }
            argc++;
        }

        if (suiteName == null) {
            usage("missing -o option");
            throw new RuntimeException();
        }

        if (classPath == null) {
            usage("missing -cp option");
            throw new RuntimeException();
        }

        File file = new File(suiteName + "." + (suiteType == Suite.EXTENDABLE_LIBRARY ? "extendable.library" : "library") + ".properties");
        if (file.exists()) {
            VM.resetSymbolsStripping(file);
        } else {
            if (suiteType == Suite.APPLICATION) {
                VM.resetSymbolsStrippingForApp();
            }
            if (userAskedForDCE) {
                if (VM.isVerbose()) {
                    System.out.println("Suite export properties file \"" + file.getPath() + "\" not found. Treating all application symbols as internal.");
                }
            } else {
                if (VM.isVerbose()) {
                    System.out.println("Suite export properties file \"" + file.getPath() + "\" not found. Dead-class elimination option disabled.");
                }
                VM.setProperty("translator.deadClassElimination", "false");
            }
        }

        // Parse class name args (if any)
        while (argc != args.length) {
            String classArg = args[argc++];
            if (classArg.equals("--")) {
                break;
            }
            ArgsUtilities.processClassArg(ArgsUtilities.toPlatformPath(classArg, false), classNames, resources);
        }

        if (!classNames.isEmpty()) {
            if (excludeFile == null && new File(suiteName + ".exclude").exists()) {
                excludeFile = suiteName + ".exclude";
            }
            if (excludeFile != null) {
                excludeClasses(classNames, excludeFile);
            }
            suite = new Suite(new File(suiteName).getName(), parentSuite, suiteType);
            for (String className: noClassDefFoundErrorClasses) {
            	if (suite.shouldThrowNoClassDefFoundErrorFor(className)) {
            		noClassDefFoundErrorClasses.remove(className);
            	}
            }
            suite.addNoClassDefFoundErrorClassNames(noClassDefFoundErrorClasses.toArray(new String[noClassDefFoundErrorClasses.size()]));
        } else {
            usage("missing class names for suite " + suiteName);
            throw new RuntimeException();
        }

        // Return the remaining args that specify a subsequent suite (if any)
        if (argc != args.length) {
            String[] newArgs = new String[args.length - argc];
            System.arraycopy(args, argc, newArgs, 0, newArgs.length);
            return newArgs;
        } else {
            return null;
        }
    }

    /**
     * Strips classes from a list of class names based on an excludes file.
     *
     * @param classNames   the list of class names to modify
     * @param excludeFile  the name of the excludes file to use
     */
    private void excludeClasses(Vector<String> classNames, String excludeFile) {

        // The exclusions are remembered in a field so that the generated
        // suite can be verified not to include any classes that should have been excluded
        excludes = readExcludesFile(excludeFile);

        Vector<String> filteredClassNames = new Vector<String>(classNames.size());
        boolean firstLoop = true;
        for (String className : classNames) {
            boolean include = true;
            for (String spec : excludes) {
                if (firstLoop && VM.isVerbose()) {
                    System.out.println("excluding: " + spec);
                }
                boolean isPrefix = spec.endsWith("*");
                if (isPrefix) {
                    spec = spec.substring(0, spec.length() - 1);
                }
                if (isPrefix ? className.startsWith(spec) : className.equals(spec)) {
                    include = false;
                    break;
                }
			}
            if (include) {
                filteredClassNames.addElement(className);
            }
            firstLoop = false;
		}

        classNames.removeAllElements();
        classNames.addAll(filteredClassNames);
    }

    /**
     * Create a sorted array of classes names, such as that romized classes appear earlier than
     * non-romized classes, and are otherwise sorted by name.
     */
    String[] createSortedClassList(Vector<String> classNames) {
        String[] sortedClassNames = new String[classNames.size()];
        classNames.copyInto(sortedClassNames);
        Arrays.sort(sortedClassNames, new Comparator<String>() {
            public int compare(String object1, String object2) {
                boolean romize1 = CHeaderFileCreator.isRomizedClass(object1);
                boolean romize2 = CHeaderFileCreator.isRomizedClass(object2);
                if (romize1 && !romize2) {
                    return -1;
                } else if (!romize1 && romize2) {
                    return 1;
                } else {
                    return object1.compareTo(object2);
                }
            }
        });
        return sortedClassNames;
    }

    /**
     * Loads and translates the classes in the suite.
     *
     * @param  classNames the names of the classes that are to be translated
     */
    private void translate(Vector<String> classNames) {
        if (classNames.isEmpty()) {
            throw new RuntimeException("No classes found for "+suite);
        }

        System.out.println("[translating "+suite+" ...]");

        VM.setCurrentIsolate(null);
        Isolate isolate = new Isolate(null, null, suite);
        VM.setCurrentIsolate(isolate);

        isolate.setTranslator(new Translator());
        TranslatorInterface translator = isolate.getTranslator();
        try {
	        translator.open(suite, classPath);
        	suite.addNoClassDefFoundErrorClassNames(noClassDefFoundErrorClasses.toArray(new String[noClassDefFoundErrorClasses.size()]));

            if (suite.isBootstrap() && (previous != null)) {
                // Trying to create bootstrap suite, but previous romize failed. Need to copy over the previous boot classes to new bootstrap suite
                suite.reinstallBootClasses(previous.suite);
            }

	        // Sort the classes in order to make sure that regardless of what platform we are on
	        // the order of the classes will be the same
	        String[] sortedClassNames = createSortedClassList(classNames);
	        // Create classes for each class name
	        for (String className: sortedClassNames) {
	        	if (noClassDefFoundErrorClasses.indexOf(className) == -1) {
	        		Klass.getClass(className, false);
	        	}
	        }

	        // Compute the complete class closure.
	        translator.close(suiteType);
        } catch (com.sun.squawk.translator.VerifyError t) {
            System.err.println(t);
    		lastClassName = translator.getLastClassName();
        	throw t;
        } catch (NoClassDefFoundError t) {
    		lastClassName = translator.getLastClassName();
        	throw t;
        }

        // Ensure no classes that were meant to be excluded have been included
        // do later on stripped suite...
        //verifyExclusions(suite);
    }

    /**
     * Ensures that no classes that were meant to be excluded have been included in a given suite.
     * If an exclusion was violated, then a warning is sent to the console.
     *
     * @param suite  the suite to verify
     */
    private void verifyExclusions(Suite suite) {
        if (excludes != null) {
            for (int i = 0; i != suite.getClassCount(); ++i) {
                Klass klass = suite.getKlass(i);
                if (klass == null) {
                    continue;
                }

                String className = klass.getInternalName();
                for (String spec : excludes) {
                    if (spec.endsWith("*") ? className.startsWith(spec.substring(0, spec.length() - 1)) : className.equals(spec)) {
                        System.err.println("**WARNING**: suite includes class '" + className + "' that is matched by exclusion spec '" + spec + "'");
                    }
				}
            }
        }
    }

    /*---------------------------------------------------------------------------*\
     *                             Image building                                *
    \*---------------------------------------------------------------------------*/

    /**
     * Creates the serialized object memory representing the classes in the translated suite.
     */
	private void createImage() throws IOException {

        // Open the map file.
        File file = new File(suiteName + ".sym");
        PrintStream symbols = VM.Streams[VM.STREAM_SYMBOLS] = new PrintStream(new FileOutputStream(file));
        generatedFiles.addElement(file.getAbsolutePath());

        GC.setAllocationEnabled(true);

        // Strip the symbols in the suite and close it.
        Suite strippedSuite = suite.strip(suiteType, suite.getName(), suite.getParent());
        strippedSuite.close();
        // Ensure no classes that were meant to be excluded have been included
        verifyExclusions(strippedSuite);

        String suiteFileName = suiteName + Suite.FILE_EXTENSION;
        String url = "file://" + suiteFileName;
        DataOutputStream dos = Connector.openDataOutputStream(url);

        // Save the (canonical) address at which the suite will be saved
        int memoryStart = NativeUnsafe.getMemorySize();

        // The boostrap suite has a special URI
        String uri = strippedSuite.getParent() == null ? ObjectMemory.BOOTSTRAP_URI : url;
        strippedSuite.save(dos, uri, VM.isBigEndian());
        generatedFiles.addElement(new File(suiteFileName).getAbsolutePath());

        // Create the <suiteName>.metadata file of all the class files from which the suite was created
        if (createMetadata) {
            String metadataUrl = "file://" + suiteFileName + Suite.FILE_EXTENSION_METADATA;
            DataOutputStream metadataDos = Connector.openDataOutputStream(metadataUrl);
            Suite metadataSuite = suite.strip(Suite.METADATA, suiteFileName + Suite.FILE_EXTENSION_METADATA, strippedSuite);
            if (metadataSuite.getClassCount() != 0) {
              throw new RuntimeException("Metadata suites should not have any classes. " + metadataSuite + " has " + metadataSuite.getClassCount());
            }

            metadataSuite.close();
            int memorySizePrior = NativeUnsafe.getMemorySize();
            ObjectMemory objectMemory;
            ObjectGraphSerializer.pushObjectMap();
            try {
            	objectMemory = metadataSuite.save(metadataDos, metadataUrl, VM.isBigEndian());
            } finally {
            	ObjectGraphSerializer.popObjectMap();
            }
            GC.unRegisterReadOnlyObjectMemory(objectMemory);
            NativeUnsafe.setMemorySize(memorySizePrior);
            GC.setAllocTop(Address.zero().add(memorySizePrior));
            generatedFiles.addElement(new File(suiteFileName + Suite.FILE_EXTENSION_METADATA).getAbsolutePath());
        }

        // Create the <suiteName>_classes.jar file of all the class files from which the suite was created
        // base on the unstripped suite, which allows classes that are only used on host to end up in jar,
        // even though eliminated from suite.
        if (createJars) {
            String jarFilePath = suiteName + "_classes.jar";
            File jarFile = new File(jarFilePath);
            jarClasses(jarFile, suite, false);
            generatedFiles.addElement(jarFile.getAbsolutePath());
            if (java5ClassPath != null) {
                jarFilePath = suiteName + "_java5.jar";
                jarFile = new File(jarFilePath);
                jarClasses(jarFile, suite, true);
                generatedFiles.addElement(jarFile.getAbsolutePath());
            }
        }

        // TODO: Do we really need to do this???
        // Ensures that saving worked
        NativeUnsafe.setMemorySize(memoryStart);
        ObjectMemory memory = ObjectMemoryLoader.load(Connector.openDataInputStream(url), url, false).objectMemory;

        printSymFile(memory, symbols);
    }

    private void printSymFile(ObjectMemory memory, PrintStream symbols) throws IOException {
        // Add a few symbols.
        VM.printNatives(symbols);
        symbols.println("PMR.ROM_SIZE=" + memory.getSize());
        symbols.println("PMR.ROM_SUITE_TABLE=" + memory.getRoot());
        symbols.println("PMR.REVERSE_PARAMETERS=" + (Translator.REVERSE_PARAMETERS ? 1 : 0));

        printGlobalVariables(symbols);
        printGlobalAddresses(symbols);
        printGlobalOops(symbols);

        symbols.close();
    }

	@SuppressWarnings("unchecked")
	private void printGlobalAddresses(PrintStream symbols) {
        Hashtable<String, Integer> globalAddrs = (Hashtable<String, Integer>) InstructionEmitter.getGlobalAddrVariables();
        symbols.println("ROM.GLOBAL.ADDR.COUNT="+globalAddrs.size());
        for (Map.Entry<String, Integer> entry : globalAddrs.entrySet()) {
            symbols.println("ROM.GLOBAL.ADDR." + entry.getValue() + "=" + entry.getKey());
        }
	}


    @SuppressWarnings("unchecked")
	private void printGlobalOops(PrintStream symbols) {
        Hashtable<String, Integer> globalOops = (Hashtable<String, Integer>) InstructionEmitter.getGlobalOopVariables();
        symbols.println("ROM.GLOBAL.OOP.COUNT="+globalOops.size());
        for (Map.Entry<String, Integer> entry : globalOops.entrySet()) {
            symbols.println("ROM.GLOBAL.OOP." + entry.getValue() + "=" + entry.getKey());
        }
	}


	@SuppressWarnings("unchecked")
	private void printGlobalVariables(PrintStream symbols) {
        Hashtable<String, Integer> globalInts = (Hashtable<String, Integer>) InstructionEmitter.getGlobalIntVariables();
        symbols.println("ROM.GLOBAL.INT.COUNT="+globalInts.size());
        for (Map.Entry<String, Integer> entry : globalInts.entrySet()) {
            symbols.println("ROM.GLOBAL.INT." + entry.getValue() + "=" + entry.getKey());
        }
	}

	/**
     * Return the name of the class that caused the last NoClassDefFoundError.
	 */
	protected String getLastClassName() {
		return lastClassName;
	}

	/**
     * Creates a jar file of all the class files from which a given suite was built.
     *
     * @param file   the jar file to create
     * @param suite  the suite to jar
     */
    private void jarClasses(File file, Suite suite, boolean doJava5) {
        try {
            FileOutputStream fos = new FileOutputStream(file);
            ZipOutputStream zos = new JarOutputStream(fos);
            ClasspathConnection cp = (ClasspathConnection)Connector.open("classpath://" + (doJava5? this.java5ClassPath:this.classPath));
            for (int i = 0; i < suite.getClassCount(); i++) {
                Klass klass = suite.getKlass(i);
                if (klass == null || klass.isSynthetic()) {
                    continue;
                }

                String classFilePath = klass.getName().replace('.', '/') + ".class";
                addFileToJar(zos, cp, classFilePath);
            }
            zos.close();
        } catch (IOException e) {
            throw new RuntimeException("IO error creating jar file", e);
        }
    }

    /**
     * Adds a given file to a given jar file stream.
     *
     * @param zos        the jar stream
     * @param classPath  where to find the file
     * @param filePath   the path to the file
     * @throws IOException if there is an IO error
     */
    private void addFileToJar(ZipOutputStream zos, ClasspathConnection classPath, String filePath) throws IOException {
        byte[] data = classPath.getBytes(filePath);

        ZipEntry e = new ZipEntry(filePath);
        e.setTime(System.currentTimeMillis());
        zos.putNextEntry(e);
        zos.write(data);
        zos.closeEntry();
    }


    /*---------------------------------------------------------------------------*\
     *                           C header file generation                        *
    \*---------------------------------------------------------------------------*/

    /**
     * Creates the C header file required by the C implementation of the Squawk interpreter.
     *
     * @throws IOException if an IO error occurs
     */
    private void createCHeader() throws IOException {
        File headerFile = new File("vmcore/src/vm/rom.h");
        Properties symbols = new Properties();
        symbols.load(new FileInputStream(suiteName + ".sym"));

        if (CHeaderFileCreator.update(suite, headerFile, symbols)) {
            generatedFiles.addElement(headerFile.getAbsolutePath());
        } else {
            System.out.println(headerFile.getAbsolutePath() + " is already up to date");
        }
    }

    /*---------------------------------------------------------------------------*\
     *                           Create squawk_rt.jar                            *
    \*---------------------------------------------------------------------------*/

    /**
     * Generates a text file describing the components in the
     * suite that can be dynamically bound to.
     */
    private void createSuiteAPI() throws IOException {
        Suite apiSuite = this.suite.strip(suiteType, this.suite.getName(), this.suite.getParent());
        File api = new File(suiteName + Suite.FILE_EXTENSION + Suite.FILE_EXTENSION_API);
        PrintStream out = new PrintStream(new FileOutputStream(api));
        printAPI(out, apiSuite);
        generatedFiles.addElement(api.getAbsolutePath());
        out.close();
    }

    /*---------------------------------------------------------------------------*\
     *                            API Printing                                   *
    \*---------------------------------------------------------------------------*/

    /**
     * Prints a textual description of the components in this suite that can be linked
     * against. That is, the components whose symbolic information has not been stripped.
     *
     * @param out where to print the description
     */
    public static void printAPI(PrintStream out, Suite suite) {

        out.println(".suite " + suite.getName());
        for (int i = 0; i != suite.getClassCount(); ++i) {
            Klass klass = suite.getKlass(i);
            KlassMetadata metadata;
            if (klass == null ||
                klass.isSynthetic() ||
                klass.isSourceSynthetic() ||
                klass == Klass.STRING_OF_BYTES ||
                isAnonymousOrPrivate(klass.getName()) ||
                (metadata = suite.getMetadata(klass)) == null)
            {
                continue;
            }

            out.println(".class " + klass.getName());
            printFieldsAPI(out, metadata, SymbolParser.STATIC_FIELDS);
            printFieldsAPI(out, metadata, SymbolParser.INSTANCE_FIELDS);
            printMethodsAPI(out, metadata, SymbolParser.STATIC_METHODS);
            printMethodsAPI(out, metadata, SymbolParser.VIRTUAL_METHODS);
        }
    }

    private static boolean isAnonymousOrPrivate(String className) {
        int index = className.lastIndexOf('$');
        if (index == -1) {
            return false;
        }
        if (className.length() > index + 1) {
            char c = className.charAt(index + 1);
            return c >= '0' && c <= '9';
        }
        return false;
    }

    private static void printFieldsAPI(PrintStream out, KlassMetadata klass, int category) {
        SymbolParser symbols = klass.getSymbolParser();
        int count = symbols.getMemberCount(category);
        for (int i = 0; i != count; ++i) {
            int id = symbols.getMemberID(category, i);
            Field field = new Field(klass, id);
            if (!field.isSourceSynthetic()) {
                out.println("    .field " + field.getName() + ' ' + field.getType().getSignature());
            }
        }
    }

    private static void printMethodsAPI(PrintStream out, KlassMetadata klass, int category) {
        SymbolParser symbols = klass.getSymbolParser();
        int count = symbols.getMemberCount(category);
        for (int i = 0; i != count; ++i) {
            int id = symbols.getMemberID(category, i);
            Method method = new Method(klass, id);

            if (method.isNative() && !VM.isLinkableNativeMethod(method.getFullyQualifiedName())) {
                continue;
            }

            if (method.isInterpreterInvoked()) {
                continue;
            }

            if (method.isSourceSynthetic() || method.isClassInitializer()) {
                continue;
            }

            out.print("    .method " + method.getName() + " (");
            Klass[] types = method.getParameterTypes();
            for (int j = 0; j != types.length; ++j) {
                Klass type = types[j];
                out.print(type.getSignature());
            }
            out.println(")" + (method.isConstructor() ? "V" : method.getReturnType().getSignature()));
        }
    }

}
