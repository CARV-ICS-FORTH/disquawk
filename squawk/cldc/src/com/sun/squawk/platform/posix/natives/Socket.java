//if[!AUTOGEN_JNA_NATIVES]
/*
 * Copyright     2015, FORTH-ICS / CARV
 *                    (Foundation for Research & Technology -- Hellas,
 *                     Institute of Computer Science,
 *                     Computer Architecture & VLSI Systems Laboratory)
 * Copyright 2004-2008 Sun Microsystems, Inc. All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER
 *
 * This code is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2
 * only, as published by the Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License version 2 for more details (a copy is
 * included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License
 * version 2 along with this work; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *
 * Please contact Sun Microsystems, Inc., 16 Network Circle, Menlo
 * Park, CA 94025 or visit www.sun.com if you need additional
 * information or have any questions.
 */

/* **** GENERATED FILE -- DO NOT EDIT ****
 *      This is a CLDC/JNA Interface class definition
 *      generated by com.sun.cldc.jna.JNAGen
 *      from the CLDC/JNA Interface class declaration in ./cldc-native-declarations/src/com/sun/squawk/platform/posix/natives/Socket.java
 */
package com.sun.squawk.platform.posix.natives;

import com.sun.cldc.jna.*;
import com.sun.cldc.jna.ptr.*;

/**
 *
 * java wrapper around BSD sockets
 */
/*@Includes({"<sys/socket.h>", "<netinet/in.h>"})*/
public interface Socket extends Library {
    Socket INSTANCE = (Socket)
            Native.loadLibrary("socket",
                               Socket.class);

    /* Supported address families. */
    public final static int AF_INET = INSTANCE.initConstInt(0);
    
    /* Socket types. */
    public final static int SOCK_STREAM = INSTANCE.initConstInt(1); /* stream (connection) socket	*/
    public final static int SOCK_DGRAM  = INSTANCE.initConstInt(2); /* datagram (conn.less) socket	*/
    public final static int SOCK_RAW    = INSTANCE.initConstInt(3); /* raw socket			*/
    
    /* Definitions of bits in internet address integers. */
    public final static int INADDR_ANY      = INSTANCE.initConstInt(4);
    
    public final static int INET_ADDRSTRLEN = INSTANCE.initConstInt(5);
    
    /* Socket options */
    /*
     * Level number for (get/set)sockopt() to apply to socket itself.
     */
    public final static int SOL_SOCKET = INSTANCE.initConstInt(6);      /* options for socket level */
    /*
     * Option flags per-socket.
     */
    public final static int SO_DEBUG        = INSTANCE.initConstInt(7); /* turn on debugging info recording */
    public final static int SO_ACCEPTCONN   = INSTANCE.initConstInt(8); /* socket has had listen() */
    public final static int SO_REUSEADDR    = INSTANCE.initConstInt(9); /* allow local address reuse */
    public final static int SO_KEEPALIVE    = INSTANCE.initConstInt(10);	/* keep connections alive */
    public final static int SO_DONTROUTE    = INSTANCE.initConstInt(11);	/* just use interface addresses */
    public final static int SO_BROADCAST    = INSTANCE.initConstInt(12);	/* permit sending of broadcast msgs */
    public final static int SO_OOBINLINE    = INSTANCE.initConstInt(13);	/* leave received OOB data in line */

    public final static int IPPROTO_TCP     = INSTANCE.initConstInt(14);		/* Level number for (get/set)sockopt() to apply to TCP */

    public final static int TCP_NODELAY     = INSTANCE.initConstInt(15);		/* don't delay send to coalesce packets */

    /*
     * Additional options, not kept in so_options.
     */
    public final static int SO_SNDBUF   = INSTANCE.initConstInt(16);       /* send buffer size */
    public final static int SO_RCVBUF   = INSTANCE.initConstInt(17);       /* receive buffer size */
    public final static int SO_SNDLOWAT = INSTANCE.initConstInt(18);       /* send low-water mark */
    public final static int SO_RCVLOWAT = INSTANCE.initConstInt(19);       /* receive low-water mark */
    public final static int SO_SNDTIMEO = INSTANCE.initConstInt(20);       /* send timeout */
    public final static int SO_RCVTIMEO = INSTANCE.initConstInt(21);       /* receive timeout */
    public final static int SO_ERROR    = INSTANCE.initConstInt(22);       /* get error status and clear */
    public final static int SO_TYPE     = INSTANCE.initConstInt(23);       /* get socket type */

    /**
     * socket() creates an endpoint for communication and returns a descriptor.
     * 
     * @param domain specifies a communications domain within which communication
     *               will take place; this selects the protocol family which should
     *               be used. The currently understood formats are:
     *               AF_UNIX, AF_INET, AF_ISO, AF_NS, AF_IMPLINK
     * @param type   specifies the semantics of communication.  Currently defined types are:
     *               SOCK_STREAM, SOCK_DGRAM, SOCK_RAW, SOCK_SEQPACKET, SOCK_RDM
     * @param protocol The protocol number to use is particular to the
     *               communication domain in which communication is to take place; see
     *                protocols(5).
     * @return  A -1 is returned if an error occurs, otherwise the return value is a
     *          descriptor referencing the socket.
     */
     int socket(int domain, int type, int protocol);
     
    /**
     * initiate a connection on a socket.
     * 
     * @param socket socket descriptor
     * @param address ptr to a sockaddr_in buffer
     * @param address_len pass in sockaddr_in.size()
     * @return  A -1 is returned if an error occurs, otherwise the return value is a
     *          descriptor referencing the socket.
     */
    int connect(int socket, sockaddr_in address, int address_len);
    
    /**
     * bind a socket to a port
     * 
     * @param socket socket descriptor
     * @param myaddress ptr to a sockaddr_in buffer
     * @param address_len size of sockaddr_in
     * @return  A -1 is returned if an error occurs, otherwise the return value is a
     *          descriptor referencing the socket.
     */
    int bind(int socket, sockaddr_in myaddress, int address_len);
    
    /**
     * accept a connection from a client
     * 
     * @param socket socket descriptor
     * @param remoteAddress ptr to a SockAddr_In buffer that will contain the address of the remote client
     * @param address_len pointer to int containing the size of an IP address
     * @return  A -1 is returned if an error occurs, otherwise the return value is a
     *          descriptor referencing the socket.
     */
    int accept(int socket, sockaddr_in remoteAddress, IntByReference address_len);
     
    /**
     * listen for connections on socket
     * 
     * @param socket socket descriptor
     * @param backlog
     * @return  A -1 is returned if an error occurs, otherwise the return value is a
     *          descriptor referencing the socket.
     */
    int listen(int socket, int backlog);
    
    /**
     * initiate a connection on a socket.
     * 
     * @param socket socket descriptor
     * @param how  If how is SHUT_RD, further receives will be disallowed.  If how
     *             is SHUT_WR, further sends will be disallowed.  If how is SHUT_RDWR, further sends and
     *             receives will be disallowed.
     * @return  A -1 is returned if an error occurs, otherwise zero is returned
     */
     int shutdown(int socket, int how);
     
    /** C STRUCTURE sockaddr_in  /
     struct sockaddr_in {
        u_char  sin_len;     1
        u_char  sin_family;  1
        u_short sin_port;    2
        struct  in_addr sin_addr; 4
        char    sin_zero[8];     8
     }; 
     * 
     struct sockaddr {
	__uint8_t	sa_len;		/* total length 
	sa_family_t	sa_family;	/* [XSI] address family 
	char		sa_data[14];	/* [XSI] addr value (actually larger) 
};
     */
    public final static class sockaddr_in extends SocketImpl.sockaddr_inImpl {        
        /** u_char 
         * DOES NOT EXIST ON SOLARIS!
         */
        /*@IfNDef("sun")*/
        public int sin_len;
        
        /** u_char */
        public int sin_family;
        
        /** u_short */
        public int sin_port;
        
        /** in_addr is an opaque type that is typically a 4-byte int for IPv4.*/
        public int sin_addr;
                
        public sockaddr_in() {
            sin_len = size(); // default....
        }
        
//        public void read() {
//            Pointer p = getPointer();
//            if (layout[SIN_LEN_INDEX] >= 0) {
//                sin_len = p.getByte(layout[SIN_LEN_INDEX]) & 0xFF;
//                sin_family = p.getByte(layout[SIN_FAMILY_INDEX]) & 0xFF;
//            } else {    // Solaris and ?
//                sin_family = p.getShort(layout[SIN_FAMILY_INDEX]) & 0xFFFF;
//            }
//            sin_port    = p.getShort(layout[SIN_PORT_INDEX]) & 0xFFFF;
//            sin_addr    = p.getInt(layout[SIN_ADDR_INDEX]);
//        }
//
//        public void write() {
//            Pointer p = getPointer();
//            clear();
//            if (layout[SIN_LEN_INDEX] >= 0) {
//                p.setByte(layout[SIN_LEN_INDEX], (byte) sin_len);
//                p.setByte(layout[SIN_FAMILY_INDEX], (byte) sin_family);
//            } else {   // Solaris and ?
//                p.setShort(layout[SIN_FAMILY_INDEX], (byte) sin_family);
//            }
//            p.setShort(layout[SIN_PORT_INDEX],  (short)sin_port);
//            p.setInt(layout[SIN_ADDR_INDEX],    sin_addr);
//        }
        
        public String toString() {
            return "Struct_SockAddr{len: " + sin_len + ", family: " + sin_family + ", port: " + sin_port + ", addr: " + sin_addr + "}";
        }
                 
    } /* SockAddr */

/*if[TRUE]*/
    /**
     * Interprets the specified character string as an Internet address, placing the
     * address into the structure provided.  It returns 1 if the string was successfully interpreted, or 0 if
     * the string is invalid
     * 
     * @param str 
     * @param in_addr (OUT) on sucessful return will contain the 32 bits of an IPv4 "struct in_addr"
     * @return true if success
     */
    boolean inet_pton(String str, IntByReference in_addr);

    /**
     * Takes an IPv4 Internet address and returns string representing the address
     * in `.' notation
     * 
     * @param af family (should be AF_INET)
     * @param src a pointer to the src internet address
     * @param dst  a pointer to tmp buffer used to store characters for the result.
     * @param size  the size of the tmp dst buffer 
     * @return String (created from the characters in the dst buffer)
     */
    String inet_ntop(int af, IntByReference src, Pointer dst, int size);
    
/*else[TRUE]*/
//    /**
//     * Interprets the specified character string as an Internet address, placing the
//     * address into the structure provided.  It returns 1 if the string was successfully interpreted, or 0 if
//     * the string is invalid
//     * 
//     * @param str 
//     * @param in_addr (OUT) on sucessful return will contain the 32 bits of an IPv4 "struct in_addr"
//     * @return true if success
//     */
//    public static boolean inet_aton(String str, IntStar in_addr) {
//        Pointer name0 = Pointer.createStringBuffer(str);
//        int result =  inet_atonPtr.call2(name0, in_addr.getPointer());
//        name0.free();
//        return (result == 0) ? false : true;
//    }
//
//    /**
//     * Takes an IPv4 Internet address and returns string representing the address
//     * in `.' notation
//     * 
//     * @param in the opaque bytes of an IPv4 "struct in_addr"
//     * @return String
//     */
//    public static String inet_ntoa(int in) {
//        return Function.returnString(inet_ntoaPtr.call1(in));
//    }
/*end[TRUE]*/
    
    /**
     * set a socket option
     * 
     * @param socket socket descriptor
     * @param level 
     * @param option_name 
     * @param option_value 
     * @param option_len (option_value.size()
     * @return  A -1 is returned if an error occurs, otherwise the return value is a
     *          descriptor referencing the socket.
     */
    int setsockopt(int socket, int level, int option_name, ByReference option_value, int option_len);
    
    /**
     * get a socket option
     * 
     * @param socket socket descriptor
     * @param level 
     * @param option_name 
     * @param option_value 
     * @param option_len On return, the by-reference int will contain the size of the option_value data
     * @return  A -1 is returned if an error occurs, otherwise the return value is a
     *          descriptor referencing the socket.
     */
    int getsockopt(int socket, int level, int option_name, ByReference option_value, IntByReference option_len);

}
