//if[!AUTOGEN_JNA_NATIVES]
/*
 * Copyright     2015, FORTH-ICS / CARV
 *                    (Foundation for Research & Technology -- Hellas,
 *                     Institute of Computer Science,
 *                     Computer Architecture & VLSI Systems Laboratory)
 * Copyright 2004-2008 Sun Microsystems, Inc. All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER
 *
 * This code is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2
 * only, as published by the Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License version 2 for more details (a copy is
 * included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License
 * version 2 along with this work; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *
 * Please contact Sun Microsystems, Inc., 16 Network Circle, Menlo
 * Park, CA 94025 or visit www.sun.com if you need additional
 * information or have any questions.
 */


/* **** GENERATED FILE -- DO NOT EDIT ****
 *      This is a CLDC/JNA Interface class definition
 *      generated by com.sun.cldc.jna.JNAGen
 *      from the CLDC/JNA Interface class declaration in ./cldc-native-declarations/src/com/sun/squawk/platform/posix/natives/LibC.java
 */
package com.sun.squawk.platform.posix.natives;

import com.sun.cldc.jna.*;

/**
 *
 * Import common functions variables and constants from libc.
 */
/*@Includes({"<errno.h>", "<fcntl.h>", "<sys/stat.h>"})*/
public interface LibC extends Library {

    LibC INSTANCE = (LibC)
            Native.loadLibrary("RTLD",
                               LibC.class);

    int 
        /* NOTE: This constant initialization is meant to be autogenerated, so will be less error-prone in the future.*/
        EPERM = INSTANCE.initConstInt(0), /* Operation not permitted */

        ENOENT = INSTANCE.initConstInt(1),		/* No such file or directory */

        ESRCH = INSTANCE.initConstInt(2),		/* No such process */

        EINTR = INSTANCE.initConstInt(3),		/* Interrupted system call */

        EIO = INSTANCE.initConstInt(4),		/* Input/output error */

        ENXIO = INSTANCE.initConstInt(5),		/* Device not configured */

        E2BIG = INSTANCE.initConstInt(6),		/* Argument list too long */

        ENOEXEC = INSTANCE.initConstInt(7),		/* Exec format error */

        EBADF = INSTANCE.initConstInt(8),		/* Bad file descriptor */

        ECHILD = INSTANCE.initConstInt(9),		/* No child processes */

        EDEADLK = INSTANCE.initConstInt(10),		/* Resource deadlock avoided */
        /* 11 was EAGAIN */

        ENOMEM = INSTANCE.initConstInt(11),		/* Cannot allocate memory */

        EACCES = INSTANCE.initConstInt(12),		/* Permission denied */

        EFAULT = INSTANCE.initConstInt(13),		/* Bad address */

        EBUSY = INSTANCE.initConstInt(14),		/* Device busy */

        EEXIST = INSTANCE.initConstInt(15),		/* File exists */

        EXDEV = INSTANCE.initConstInt(16),		/* Cross-device link */

        ENODEV = INSTANCE.initConstInt(17),		/* Operation not supported by device */

        ENOTDIR = INSTANCE.initConstInt(18),		/* Not a directory */

        EISDIR = INSTANCE.initConstInt(19),		/* Is a directory */

        EINVAL = INSTANCE.initConstInt(20),		/* Invalid argument */

        ENFILE = INSTANCE.initConstInt(21),		/* Too many open files in system */

        EMFILE = INSTANCE.initConstInt(22),		/* Too many open files */

        ENOTTY = INSTANCE.initConstInt(23),		/* Inappropriate ioctl for device */

        ETXTBSY = INSTANCE.initConstInt(24),		/* Text file busy */

        EFBIG = INSTANCE.initConstInt(25),		/* File too large */

        ENOSPC = INSTANCE.initConstInt(26),		/* No space left on device */

        ESPIPE = INSTANCE.initConstInt(27),		/* Illegal seek */

        EROFS = INSTANCE.initConstInt(28),		/* Read-only file system */

        EMLINK = INSTANCE.initConstInt(29),		/* Too many links */

        EPIPE = INSTANCE.initConstInt(30),		/* Broken pipe */

        /* math software */
        EDOM = INSTANCE.initConstInt(31),		/* Numerical argument out of domain */

        ERANGE = INSTANCE.initConstInt(32),		/* Result too large */

        /* non-blocking and interrupt i/o */
        EAGAIN = INSTANCE.initConstInt(33),		/* Resource temporarily unavailable */

        EWOULDBLOCK = INSTANCE.initConstInt(34),		/* Operation would block */

        EINPROGRESS = INSTANCE.initConstInt(35),		/* Operation now in progress */

        EALREADY = INSTANCE.initConstInt(36),		/* Operation already in progress */

        /* ipc/network software -- argument errors */
        ENOTSOCK = INSTANCE.initConstInt(37),		/* Socket operation on non-socket */

        EDESTADDRREQ = INSTANCE.initConstInt(38),		/* Destination address required */

        EMSGSIZE = INSTANCE.initConstInt(39),		/* Message too long */

        EPROTOTYPE = INSTANCE.initConstInt(40),		/* Protocol wrong type for socket */

        ENOPROTOOPT = INSTANCE.initConstInt(41),		/* Protocol not available */

        EPROTONOSUPPORT = INSTANCE.initConstInt(42),		/* Protocol not supported */

        ENOTSUP = INSTANCE.initConstInt(43),		/* Operation not supported */

        EAFNOSUPPORT = INSTANCE.initConstInt(44),		/* Address family not supported by protocol family */

        EADDRINUSE = INSTANCE.initConstInt(45),		/* Address already in use */

        EADDRNOTAVAIL = INSTANCE.initConstInt(46),		/* Can't assign requested address */

        /* ipc/network software -- operational errors */
        ENETDOWN = INSTANCE.initConstInt(47),		/* Network is down */

        ENETUNREACH = INSTANCE.initConstInt(48),		/* Network is unreachable */

        ENETRESET = INSTANCE.initConstInt(49),		/* Network dropped connection on reset */

        ECONNABORTED = INSTANCE.initConstInt(50),		/* Software caused connection abort */

        ECONNRESET = INSTANCE.initConstInt(51),		/* Connection reset by peer */

        ENOBUFS = INSTANCE.initConstInt(52),		/* No buffer space available */

        EISCONN = INSTANCE.initConstInt(53),		/* Socket is already connected */

        ENOTCONN = INSTANCE.initConstInt(54),		/* Socket is not connected */

        ETIMEDOUT = INSTANCE.initConstInt(55),		/* Operation timed out */

        ECONNREFUSED = INSTANCE.initConstInt(56),		/* Connection refused */

        ELOOP = INSTANCE.initConstInt(57),	/* Too many levels of symbolic links */

        ENAMETOOLONG = INSTANCE.initConstInt(58),		/* File name too long */

        /* should be rearranged */
        EHOSTUNREACH = INSTANCE.initConstInt(59),		/* No route to host */

        ENOTEMPTY = INSTANCE.initConstInt(60),		/* Directory not empty */

        /* quotas & mush */
        EDQUOT = INSTANCE.initConstInt(61),		/* Disc quota exceeded */

        ENOLCK = INSTANCE.initConstInt(62),		/* No locks available */

        ENOSYS = INSTANCE.initConstInt(63),		/* Function not implemented */

        EOVERFLOW = INSTANCE.initConstInt(64),		/* Value too large to be stored in data type */

        ECANCELED = INSTANCE.initConstInt(65),		/* Operation canceled */

        EIDRM = INSTANCE.initConstInt(66),		/* Identifier removed */

        ENOMSG = INSTANCE.initConstInt(67),		/* No message of desired type */

        EILSEQ = INSTANCE.initConstInt(68),		/* Illegal byte sequence */

        EBADMSG = INSTANCE.initConstInt(69),		/* Bad message */

        EMULTIHOP = INSTANCE.initConstInt(70),		/* Reserved */

        ENODATA = INSTANCE.initConstInt(71),		/* No message available on STREAM */

        ENOLINK = INSTANCE.initConstInt(72),		/* Reserved */

        ENOSR = INSTANCE.initConstInt(73),		/* No STREAM resources */

        ENOSTR = INSTANCE.initConstInt(74),		/* Not a STREAM */

        EPROTO = INSTANCE.initConstInt(75),		/* Protocol error */

        ETIME = INSTANCE.initConstInt(76),		/* STREAM ioctl timeout */


        /* command values */
        F_DUPFD		= INSTANCE.initConstInt(77),		/* duplicate file descriptor */
        F_GETFD		= INSTANCE.initConstInt(78),		/* get file descriptor flags */
        F_SETFD		= INSTANCE.initConstInt(79),		/* set file descriptor flags */
        F_GETFL		= INSTANCE.initConstInt(80),	/* get file status flags */
        F_SETFL		= INSTANCE.initConstInt(81),		/* set file status flags */

        /*
         * File status flags: these are used by open(2), fcntl(2).
         * They are also used (indirectly) in the kernel file structure f_flags,
         * which is a superset of the open/fcntl flags.  Open flags and f_flags
         * are inter-convertible using OFLAGS(fflags) and FFLAGS(oflags).
         * Open/fcntl flags begin with O_; kernel-internal flags begin with F.
         */
        /* open-only flags */
            O_RDONLY	= INSTANCE.initConstInt(82),		/* open for reading only */
            O_WRONLY	= INSTANCE.initConstInt(83),		/* open for writing only */
            O_RDWR		= INSTANCE.initConstInt(84),		/* open for reading and writing */
            O_ACCMODE	= INSTANCE.initConstInt(85),		/* mask for above modes */

            O_NONBLOCK	= INSTANCE.initConstInt(86),		/* no delay */
            O_APPEND	= INSTANCE.initConstInt(87),		/* set append mode */
            O_SYNC		= INSTANCE.initConstInt(88),		/* synchronous writes */
            O_CREAT		= INSTANCE.initConstInt(89),		/* create if nonexistant */
            O_TRUNC		= INSTANCE.initConstInt(90),		/* truncate to zero length */
            O_EXCL		= INSTANCE.initConstInt(91),		/* error if already exists */
        /* [XSI] directory restrcted delete */

        /* [XSI] directory */  S_IFBLK = INSTANCE.initConstInt(92),
        /* [XSI] named pipe (fifo) */ S_IFCHR = INSTANCE.initConstInt(93),
        /* [XSI] character special */ S_IFDIR = INSTANCE.initConstInt(94),
        /* [XSI] type of file mask */ S_IFIFO = INSTANCE.initConstInt(95),
        /* [XSI] regular */ S_IFLNK = INSTANCE.initConstInt(96),
        /*
         * [XSI] The following are symbolic names for the values of type mode_t.  They
         * are bitmap values.
         */
        /* File type */
        S_IFMT = INSTANCE.initConstInt(97),
        /* [XSI] block special */ S_IFREG = INSTANCE.initConstInt(98),
        /* [XSI] symbolic link */ S_IFSOCK = INSTANCE.initConstInt(99),
        /* [XSI] RWX mask for group */ S_IRGRP = INSTANCE.initConstInt(100),
        /* [XSI] RWX mask for other */ S_IROTH = INSTANCE.initConstInt(101),
        /* [XSI] RWX mask for owner */ S_IRUSR = INSTANCE.initConstInt(102),
        /* [XSI] X for owner */ /* Read, write, execute/search by group */
        S_IRWXG = INSTANCE.initConstInt(103),
        /* [XSI] X for group */ /* Read, write, execute/search by others */
        S_IRWXO = INSTANCE.initConstInt(104),
        /* [XSI] socket */

        /* File mode */
        /* Read, write, execute/search by owner */
        S_IRWXU = INSTANCE.initConstInt(105),
        /* [XSI] set user id on execution */ S_ISGID = INSTANCE.initConstInt(106),
        /* [XSI] X for other */ S_ISUID = INSTANCE.initConstInt(107),
        /* [XSI] set group id on execution */ S_ISVTX = INSTANCE.initConstInt(108),
        /* [XSI] R for group */ S_IWGRP = INSTANCE.initConstInt(109),
        /* [XSI] R for other */ S_IWOTH = INSTANCE.initConstInt(110),
        /* [XSI] R for owner */ S_IWUSR = INSTANCE.initConstInt(111),
        /* [XSI] W for group */ S_IXGRP = INSTANCE.initConstInt(112),
        /* [XSI] W for other */ S_IXOTH = INSTANCE.initConstInt(113),
        /* [XSI] W for owner */ S_IXUSR = INSTANCE.initConstInt(114),

            /** set file offset to offset */
            SEEK_SET = INSTANCE.initConstInt(115),
            /** set file offset to current plus offset */
            SEEK_CUR = INSTANCE.initConstInt(116),
            /** set file offset to EOF plus offset */
            SEEK_END = INSTANCE.initConstInt(117),

          EOPNOTSUPP = INSTANCE.initConstInt(118)		/* operation not supported on a socket */

        ; // END OF DEFINES
    
    /**
     * provides for control over descriptors.
     *
     * @param fd a descriptor to be operated on by cmd
     * @param cmd one of the cmd constants
     * @param arg 
     * @return a value that depends on the cmd.
     */
    int fcntl(int fd, int cmd, int arg);
    
    /**
     * open or create a file for reading or writing
     *
     * @param name String
     * @param oflag std libc open flags
     * @param mode  the mode for any created file
     * @return If successful, returns a non-negative integer, termed a file descriptor.  Returns
     *         -1 on failure, and sets errno to indicate the error.
     */
    int open(String name, int oflag, int mode);
    
    /**
     * delete a descriptor
     * 
     * @param fd a descriptor to be operated on by cmd
     * @return Upon successful completion, a value of 0 is returned.  Otherwise, a value of -1 is returned
     *         and the global integer variable errno is set to indicate the error.
     */
    int close(int fd);
    
    /**
     * Flush output on a descriptor
     * 
     * @param fd a descriptor to be flushed
     * @return Upon successful completion, a value of 0 is returned.  Otherwise, a value of -1 is returned
     *         and the global integer variable errno is set to indicate the error.
     */
    int fsync(int fd);

    /**
     * reposition read/write file offset
     * 
     * @param fd file descriptor
     * @param offset the offset to seek to
     * @param whence the kind of offset (SEEK_SET, SEEK_CUR, or SEEK_END)
     * @return the resulting offset location as measured in
     *         bytes from the beginning of the file.  If error, -1 is returned and errno is set
     *         to indicate the error.
     */
    int lseek(int fd, long offset, int whence);
    
    /**
     * read input
     * 
     * @param fd file descriptor
     * @param buf data buffer to read into
     * @param nbyte number of bytes to read
     * @return the number of bytes actually read is returned.  Upon reading end-of-file, zero
     *         is returned.  If error, a -1 is returned and the global variable errno is set to indicate
     *         the error
     */
    int read(int fd, byte[] buf, int nbyte);
    
    /**
     * write output
     * 
     * @param fd file descriptor
     * @param buf data buffer to write
     * @param nbyte number of bytes to read
     * @return the number of bytes which were written is returned.  If error,
     *         -1 is returned and the global variable errno is set to indicate the error.
     */
    int write(int fd, byte[] buf, int nbyte);
    
    /**
     * C struct stat
     * //    struct stat {
     * //        dev_t		st_dev;		/* [XSI] ID of device containing file             4 0
     * //        ino_t	  	st_ino;		/* [XSI] File serial number                       4 4
     * //        mode_t	 	st_mode;	/* [XSI] Mode of file (see below)             2 8
     * //        nlink_t		st_nlink;	/* [XSI] Number of hard links                 2 10
     * //        uid_t		st_uid;		/* [XSI] User ID of the file                      4 12
     * //        gid_t		st_gid;		/* [XSI] Group ID of the file                     4 16
     * //        dev_t		st_rdev;	/* [XSI] Device ID                                4 20
     * //        time_t		st_atime;	/* [XSI] Time of last access                  4 24
     * //        long		st_atimensec;	/* nsec of last access                        4 28
     * //        time_t		st_mtime;	/* [XSI] Last data modification time          4 32
     * //        long		st_mtimensec;	/* last data modification nsec                4 36
     * //        time_t		st_ctime;	/* [XSI] Time of last status change           4 40
     * //        long		st_ctimensec;	/* nsec of last status change                 4 44
     * //        off_t		st_size;	/* [XSI] file size, in bytes                      8 48
     * //        blkcnt_t	st_blocks;	/* [XSI] blocks allocated for file                8
     * //        blksize_t	st_blksize;	/* [XSI] optimal blocksize for I/O                4
     * //        __uint32_t	st_flags;	/* user defined flags for file                4
     * //        __uint32_t	st_gen;		/* file generation number                     4
     * //        __int32_t	st_lspare;	/* RESERVED: DO NOT USE!                          4
     * //        __int64_t	st_qspare[2];	/* RESERVED: DO NOT USE!                      16
     * //     };
     */
    public static class stat extends LibCImpl.statImpl {
        /** mode_t */
        public int st_mode;
        /** time_t Last data modification time */
        public int st_mtime;
        /** file size, in bytes */
        public long st_size;

    }
    
   /**
     * Get information on the open file with file descriptor "fd".
     *
     * @param fd file descriptor
     * @param stat Stat structure that will be filled with the current values
     * @return -1 is returned if an error occurs, otherwise zero is returned
     */
    int fstat(int fd, stat stat);

    /**
     * Get information on the named "name".
     *
     * @param name String
     * @param stat Stat structure that will be filled with the current values
     * @return -1 is returned if an error occurs, otherwise zero is returned
     */
    int stat(String name, stat stat);

    /**
     * Remove the directory entry for name (may delete the file)
     *
     * @param name String
     * @return If successful, returns a non-negative integer, termed a file descriptor.  Returns
     *         -1 on failure, and sets errno to indicate the error.
     */
    int unlink(String name);

}
