/*
 * Copyright 2003-2008 Sun Microsystems, Inc. All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER
 * 
 * This code is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2
 * only, as published by the Free Software Foundation.
 * 
 * This code is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License version 2 for more details (a copy is
 * included in the LICENSE file that accompanied this code).
 * 
 * You should have received a copy of the GNU General Public License
 * version 2 along with this work; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 * 
 * Please contact Sun Microsystems, Inc., 16 Network Circle, Menlo
 * Park, CA 94025 or visit www.sun.com if you need additional
 * information or have any questions.
 */

#include "../platform.h"
#include <global.h>

/*
 * The techniques described below are also documented in the Java
 * GrandeNumerics Working Group report "Improving Java for Numerical
 * Computation:"
 * http://math.nist.gov/javanumerics/reports/jgfnwg-01.html
 *
 *  What is the problem?
 * ---------------------
 *
 * Briefly, the x86 is designed to operate on 80-bit double extended
 * floating-point values rather than the 64 bit and 32 bit double and
 * float values used in Java.  The x86 can be made to round to float or
 * double precision; unfortunately, this doesn't exactly emulate the pure
 * float and double called for by Java since an extended exponent range
 * is available.  The extended exponent range means the overflow and
 * underflow thresholds are different than for pure float and double.  A
 * store to memory will round a floating-point value, possibly with an
 * extended exponent, to pure float or double.  A load is then necessary
 * to get the value back into the floating-point registers for further
 * computation.  Therefore, the basic idiom for strictfp arithmetic on
 * the x86 is:
 *
 * load arg1
 * load arg2
 * fp-op on arg1 and arg2
 * store calculated fp-op result
 * reload stored result
 *
 * This idiom implements strictfp semantics for float and double addition
 * and subtraction.  However, this idiom is *not* sufficient to implement
 * strictfp semantics for double multiply and divide.  (If the rounding
 * precision is set to double, this idiom *does* work for float multiply
 * and divide since there is enough additional precision to avoid the
 * double rounding problem discussed below.)  The above idiom will
 * enforce the proper overflow threshold for double multiply and divide
 * but the underflow threshold will not be emulated properly.
 * Essentially, what is a subnormal result in pure double is first
 * rounded once to full precision (because of the extended exponent
 * range) and then rounded a second time to reduced precision when
 * constrained to the pure double exponent range.  (Subnormal numbers are
 * very small IEEE 754 values with less precision than normal numbers.)
 * This double rounding can give a different result than a single
 * rounding to a pure double subnormal.  To address this latter
 * discrepancy, a refinement of the store-reload idiom that includes
 * scaling must be used.
 *
 * The essence of the refined technique is to arrange so that what would
 * be subnormal result in pure double is calculated as a subnormal result
 * in double with extended exponent range.  This ensures all the
 * significand bits are correct.  The exponent bits are then corrected by
 * rescaling.  The scaling factor needed is a power of 2 equal to the
 * difference in maximum exponents between double extended and pure
 * double.  It is significantly faster to perform the scaling with
 * multiplies rather than divides; therefore, scaling factors with both
 * positive and negative exponents are desirable.
 *
 * Constants needed for the scaling/rescaling are
 *
 * 2^(Emax double extended - Emax double)
 *
 * and
 *
 * 2^-(Emax double extended - Emax double)
 *
 * which are equal to
 *
 * 2^(16383 - 1023) = 2^15360
 *
 * and
 *
 * 2^(16383 - 1023) = 2^-15360
 *
 * respectively.  The scaling factors are outside the range of numbers
 * that can be represented as a double.  However, they can be easily
 * generated by starting with a representable double value:
 *
 * 2^15360 ==  ((((2^960 )^2)^2)^2)^2
 * 2^-15360 == ((((2^-960)^2)^2)^2)^2
 *
 * 2^960 == 9.745314011399999E288 == longBitsToDouble(0x7bf0000000000000)
 *
 * 2^-960 = 1.0261342003245941E-289 == longBitsToDouble(0x3f0000000000000)
 *
 * d = // 2^960 or 2^(-960)
 * for(int i = 0; i < 4; i++)
 *   d *= d;
 *
 * After the double extended value is generated, The final bit patterns,
 * from most to least significant bit, are:
 *
 * 2^15360: 0x7bff 8000 0000 0000 0000
 * 2^(-15360)   0x03ff 8000 0000 0000 0000
 *
 * A few comments on why these bits are correct; the intel double
 * extended format has a 64 bit significand, a 15 bit exponent, and one
 * sign bit.  The significand is the low-order 64 bits, the sign and
 * exponent the high-oder 16 bits. Unlike other IEEE 754 formats, the
 * double extended format has an explicit "implicit bit;" since
 * floating-point numbers are normalized storing the leading bit is not
 * necessary since it is implied by the exponent value and therefore left
 * implicit in the float and double formats.  Having this bit explicit
 * leads to the "8" in the constants above.  The exponent is encoded in
 * excess 16383 format; that is, to get the encoding, take the true
 *
 * exponent value, add 16383 and store as an unsigned 15 bit value.
 *
 * Correct strictfp double multiply and divide idioms
 * ----------------------------------------------------
 * These techniques are branch free are require no special code for NaN,
 * infinities, or zeros.
 *
 * Multiply
 * ---------------
 * load arg1
 * scale arg1 by multiplying arg1 by 2^(-15360)
 * load arg2
 * multiply scaled arg1 by arg2
 * rescale product by 2^(15360)
 * store rescaled product
 * reload stored rescaled product
 *
 *
 * Divide
 * ---------------
 * load dividend
 * scale dividend by multiplying dividend by 2^(-15360)
 * load divisor
 * divide scaled dividend by divisor
 * rescale quotient by 2^(15360)
 * store rescaled quotient
 * reload stored rescaled quotient
 */

#if PROCESSOR_ARCHITECTURE_X86 && !defined(__SSE2_MATH__ )

double JFP_lib_muld(double lvalue, double rvalue) {
    long double pos_d = 9.745314011399999E288;
    long double neg_d = 1/pos_d;
	//	printf("=>JFP_lib_muld(%e, %e)\n", lvalue, rvalue);
    long double value;
    value = (((neg_d * neg_d * neg_d * neg_d * neg_d * neg_d * neg_d * neg_d *
               neg_d * neg_d * neg_d * neg_d * neg_d * neg_d * neg_d * neg_d) * lvalue) * rvalue) *
              (pos_d * pos_d * pos_d * pos_d * pos_d * pos_d * pos_d * pos_d *
               pos_d * pos_d * pos_d * pos_d * pos_d * pos_d * pos_d * pos_d);

	//	printf("   simple answer %e\n", (lvalue * rvalue));
	//	printf("   value %e\n", value);
	//	printf("<= returns %e\n", ((double)value));
    return (double)value;
}

double JFP_lib_divd(double lvalue, double rvalue) {
    long double pos_d = 9.745314011399999E288;
    long double neg_d = 1/pos_d;
	//	printf("=>JFP_lib_divd(%e, %e)\n", lvalue, rvalue);

    long double value;
    value = (((neg_d * neg_d * neg_d * neg_d * neg_d * neg_d * neg_d * neg_d *
               neg_d * neg_d * neg_d * neg_d * neg_d * neg_d * neg_d * neg_d) * lvalue) / rvalue) *
              (pos_d * pos_d * pos_d * pos_d * pos_d * pos_d * pos_d * pos_d *
               pos_d * pos_d * pos_d * pos_d * pos_d * pos_d * pos_d * pos_d);
	//	printf("   simple answer %e\n", (lvalue / rvalue));
	//	printf("   value %e\n", value);
	//	printf("<= returns %e\n", ((double)value));

    return (double)value;
}

float JFP_lib_remf(float lvalue, float rvalue) {
    float result;    
    int rrawbits = f2ib(rvalue);
    int lrawbits = f2ib(lvalue);

    if (((rrawbits == F_POS_INFINITY) || (rrawbits == F_NEG_INFINITY)) &&
        ((lrawbits & 0x7FFFFFFF) < F_POS_INFINITY)) {
        return lvalue;
    } else {
      result = fmodf(lvalue, rvalue);
        /* Retrieve the sign bit to find +/- 0.0 */
        if ((lrawbits & 0x80000000) == 0x80000000) {
	    if ((f2ib(result) & 0x80000000) != 0x80000000) {
                result *= -1;
            }
        }
        return result;
    }
}

double JFP_lib_remd(double lvalue, double rvalue) {
    double result;    
    jlong rrawbits = d2lb(rvalue);
    jlong lrawbits = d2lb(lvalue);

    if (((rrawbits == D_POS_INFINITY) || (rrawbits == D_NEG_INFINITY)) &&
        ((lrawbits & JLONG_CONSTANT(0x7FFFFFFFFFFFFFFF)) < D_POS_INFINITY)) {
        return lvalue;
    } else {
        result = fmod(lvalue, rvalue);
        /* Retrieve the sign bit to find +/- 0.0 */
        if ((lrawbits & JLONG_CONSTANT(0x8000000000000000)) == JLONG_CONSTANT(0x8000000000000000)) {
	    if ((d2lb(result) & JLONG_CONSTANT(0x8000000000000000)) != JLONG_CONSTANT(0x8000000000000000)) {
                result *= -1;
            }
        }
        return result;
    }
}

#endif /* PROCESSOR_ARCHITECTURE_X86 */

