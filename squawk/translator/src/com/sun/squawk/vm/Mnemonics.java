/*
 * Copyright 2004-2008 Sun Microsystems, Inc. All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER
 * 
 * This code is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2
 * only, as published by the Free Software Foundation.
 * 
 * This code is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License version 2 for more details (a copy is
 * included in the LICENSE file that accompanied this code).
 * 
 * You should have received a copy of the GNU General Public License
 * version 2 along with this work; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 * 
 * Please contact Sun Microsystems, Inc., 16 Network Circle, Menlo
 * Park, CA 94025 or visit www.sun.com if you need additional
 * information or have any questions.
 */

/* **** GENERATED FILE -- DO NOT EDIT ****
 *      generated by com.sun.squawk.builder.gen.Mnemonics
 */

package com.sun.squawk.vm;

import com.sun.squawk.util.Assert;

/**
 * This class defines effect of the Squawk VM instructions on the operand stack.
 *
 */
public final class Mnemonics {


    /**
     * Gets the effect of an instruction on the operand stack. Each character
     * in the returned string preceeding the ':' character denotes a type of value
     * popped from the stack and a character after the ':' denotes a type of value
     * pushed to the stack. The possible types in the string are:
     *
     *    I  int
     *    O  object/reference
     *    F  float
     *    W  address/word/offset
     *    L  long
     *    D  double
     *    *  clears the stack (only preceeds ':')
     *
     * @param  opcode  an instruction opcode
     * @return the effect of the instruction on the operand stack
     * @throws IndexOutOfBoundsException if <code>opcode</code> is not valid
     */
    public static String getMnemonic(int opcode) {
        return mnemonics[opcode];
    }
     
    public static int length() {
        return mnemonics.length;
    }
     
    private final static String[] mnemonics = { 
        "const_0",
        "const_1",
        "const_2",
        "const_3",
        "const_4",
        "const_5",
        "const_6",
        "const_7",
        "const_8",
        "const_9",
        "const_10",
        "const_11",
        "const_12",
        "const_13",
        "const_14",
        "const_15",
        "object_0",
        "object_1",
        "object_2",
        "object_3",
        "object_4",
        "object_5",
        "object_6",
        "object_7",
        "object_8",
        "object_9",
        "object_10",
        "object_11",
        "object_12",
        "object_13",
        "object_14",
        "object_15",
        "load_0",
        "load_1",
        "load_2",
        "load_3",
        "load_4",
        "load_5",
        "load_6",
        "load_7",
        "load_8",
        "load_9",
        "load_10",
        "load_11",
        "load_12",
        "load_13",
        "load_14",
        "load_15",
        "store_0",
        "store_1",
        "store_2",
        "store_3",
        "store_4",
        "store_5",
        "store_6",
        "store_7",
        "store_8",
        "store_9",
        "store_10",
        "store_11",
        "store_12",
        "store_13",
        "store_14",
        "store_15",
        "loadparm_0",
        "loadparm_1",
        "loadparm_2",
        "loadparm_3",
        "loadparm_4",
        "loadparm_5",
        "loadparm_6",
        "loadparm_7",
        "wide_m1",
        "wide_0",
        "wide_1",
        "wide_short",
        "wide_int",
        "escape",
        "escape_wide_m1",
        "escape_wide_0",
        "escape_wide_1",
        "escape_wide_short",
        "escape_wide_int",
        "catch",
        "const_null",
        "const_m1",
        "const_byte",
        "const_short",
        "const_char",
        "const_int",
        "const_long",
        "object",
        "load",
        "load_i2",
        "store",
        "store_i2",
        "loadparm",
        "loadparm_i2",
        "storeparm",
        "storeparm_i2",
        "inc",
        "dec",
        "incparm",
        "decparm",
        "goto",
        "if_eq_o",
        "if_ne_o",
        "if_cmpeq_o",
        "if_cmpne_o",
        "if_eq_i",
        "if_ne_i",
        "if_lt_i",
        "if_le_i",
        "if_gt_i",
        "if_ge_i",
        "if_cmpeq_i",
        "if_cmpne_i",
        "if_cmplt_i",
        "if_cmple_i",
        "if_cmpgt_i",
        "if_cmpge_i",
        "if_eq_l",
        "if_ne_l",
        "if_lt_l",
        "if_le_l",
        "if_gt_l",
        "if_ge_l",
        "if_cmpeq_l",
        "if_cmpne_l",
        "if_cmplt_l",
        "if_cmple_l",
        "if_cmpgt_l",
        "if_cmpge_l",
        "getstatic_i",
        "getstatic_o",
        "getstatic_l",
        "class_getstatic_i",
        "class_getstatic_o",
        "class_getstatic_l",
        "putstatic_i",
        "putstatic_o",
        "putstatic_l",
        "class_putstatic_i",
        "class_putstatic_o",
        "class_putstatic_l",
        "getfield_i",
        "getfield_b",
        "getfield_s",
        "getfield_c",
        "getfield_o",
        "getfield_l",
        "getfield0_i",
        "getfield0_b",
        "getfield0_s",
        "getfield0_c",
        "getfield0_o",
        "getfield0_l",
        "putfield_i",
        "putfield_b",
        "putfield_s",
        "putfield_o",
        "putfield_l",
        "putfield0_i",
        "putfield0_b",
        "putfield0_s",
        "putfield0_o",
        "putfield0_l",
        "invokevirtual_i",
        "invokevirtual_v",
        "invokevirtual_l",
        "invokevirtual_o",
        "invokestatic_i",
        "invokestatic_v",
        "invokestatic_l",
        "invokestatic_o",
        "invokesuper_i",
        "invokesuper_v",
        "invokesuper_l",
        "invokesuper_o",
        "invokenative_i",
        "invokenative_v",
        "invokenative_l",
        "invokenative_o",
        "findslot",
        "extend",
        "invokeslot_i",
        "invokeslot_v",
        "invokeslot_l",
        "invokeslot_o",
        "return_v",
        "return_i",
        "return_l",
        "return_o",
        "tableswitch_i",
        "tableswitch_s",
        "extend0",
        "add_i",
        "sub_i",
        "and_i",
        "or_i",
        "xor_i",
        "shl_i",
        "shr_i",
        "ushr_i",
        "mul_i",
        "div_i",
        "rem_i",
        "neg_i",
        "i2b",
        "i2s",
        "i2c",
        "add_l",
        "sub_l",
        "mul_l",
        "div_l",
        "rem_l",
        "and_l",
        "or_l",
        "xor_l",
        "neg_l",
        "shl_l",
        "shr_l",
        "ushr_l",
        "l2i",
        "i2l",
        "throw",
        "pop_1",
        "pop_2",
        "monitorenter",
        "monitorexit",
        "class_monitorenter",
        "class_monitorexit",
        "arraylength",
        "new",
        "newarray",
        "newdimension",
        "class_clinit",
        "bbtarget_sys",
        "bbtarget_app",
        "instanceof",
        "checkcast",
        "aload_i",
        "aload_b",
        "aload_s",
        "aload_c",
        "aload_o",
        "aload_l",
        "astore_i",
        "astore_b",
        "astore_s",
        "astore_o",
        "astore_l",
        "lookup_i",
        "lookup_b",
        "lookup_s",
        "pause",
        "object_wide",
        "load_wide",
        "load_i2_wide",
        "store_wide",
        "store_i2_wide",
        "loadparm_wide",
        "loadparm_i2_wide",
        "storeparm_wide",
        "storeparm_i2_wide",
        "inc_wide",
        "dec_wide",
        "incparm_wide",
        "decparm_wide",
        "goto_wide",
        "if_eq_o_wide",
        "if_ne_o_wide",
        "if_cmpeq_o_wide",
        "if_cmpne_o_wide",
        "if_eq_i_wide",
        "if_ne_i_wide",
        "if_lt_i_wide",
        "if_le_i_wide",
        "if_gt_i_wide",
        "if_ge_i_wide",
        "if_cmpeq_i_wide",
        "if_cmpne_i_wide",
        "if_cmplt_i_wide",
        "if_cmple_i_wide",
        "if_cmpgt_i_wide",
        "if_cmpge_i_wide",
        "if_eq_l_wide",
        "if_ne_l_wide",
        "if_lt_l_wide",
        "if_le_l_wide",
        "if_gt_l_wide",
        "if_ge_l_wide",
        "if_cmpeq_l_wide",
        "if_cmpne_l_wide",
        "if_cmplt_l_wide",
        "if_cmple_l_wide",
        "if_cmpgt_l_wide",
        "if_cmpge_l_wide",
        "getstatic_i_wide",
        "getstatic_o_wide",
        "getstatic_l_wide",
        "class_getstatic_i_wide",
        "class_getstatic_o_wide",
        "class_getstatic_l_wide",
        "putstatic_i_wide",
        "putstatic_o_wide",
        "putstatic_l_wide",
        "class_putstatic_i_wide",
        "class_putstatic_o_wide",
        "class_putstatic_l_wide",
        "getfield_i_wide",
        "getfield_b_wide",
        "getfield_s_wide",
        "getfield_c_wide",
        "getfield_o_wide",
        "getfield_l_wide",
        "getfield0_i_wide",
        "getfield0_b_wide",
        "getfield0_s_wide",
        "getfield0_c_wide",
        "getfield0_o_wide",
        "getfield0_l_wide",
        "putfield_i_wide",
        "putfield_b_wide",
        "putfield_s_wide",
        "putfield_o_wide",
        "putfield_l_wide",
        "putfield0_i_wide",
        "putfield0_b_wide",
        "putfield0_s_wide",
        "putfield0_o_wide",
        "putfield0_l_wide",
        "invokevirtual_i_wide",
        "invokevirtual_v_wide",
        "invokevirtual_l_wide",
        "invokevirtual_o_wide",
        "invokestatic_i_wide",
        "invokestatic_v_wide",
        "invokestatic_l_wide",
        "invokestatic_o_wide",
        "invokesuper_i_wide",
        "invokesuper_v_wide",
        "invokesuper_l_wide",
        "invokesuper_o_wide",
        "invokenative_i_wide",
        "invokenative_v_wide",
        "invokenative_l_wide",
        "invokenative_o_wide",
        "findslot_wide",
        "extend_wide",
/*if[FLOATS]*/
        "fcmpl",
        "fcmpg",
        "dcmpl",
        "dcmpg",
        "getstatic_f",
        "getstatic_d",
        "class_getstatic_f",
        "class_getstatic_d",
        "putstatic_f",
        "putstatic_d",
        "class_putstatic_f",
        "class_putstatic_d",
        "getfield_f",
        "getfield_d",
        "getfield0_f",
        "getfield0_d",
        "putfield_f",
        "putfield_d",
        "putfield0_f",
        "putfield0_d",
        "invokevirtual_f",
        "invokevirtual_d",
        "invokestatic_f",
        "invokestatic_d",
        "invokesuper_f",
        "invokesuper_d",
        "invokenative_f",
        "invokenative_d",
        "invokeslot_f",
        "invokeslot_d",
        "return_f",
        "return_d",
        "const_float",
        "const_double",
        "add_f",
        "sub_f",
        "mul_f",
        "div_f",
        "rem_f",
        "neg_f",
        "add_d",
        "sub_d",
        "mul_d",
        "div_d",
        "rem_d",
        "neg_d",
        "i2f",
        "l2f",
        "f2i",
        "f2l",
        "i2d",
        "l2d",
        "f2d",
        "d2i",
        "d2l",
        "d2f",
        "aload_f",
        "aload_d",
        "astore_f",
        "astore_d",
        "getstatic_f_wide",
        "getstatic_d_wide",
        "class_getstatic_f_wide",
        "class_getstatic_d_wide",
        "putstatic_f_wide",
        "putstatic_d_wide",
        "class_putstatic_f_wide",
        "class_putstatic_d_wide",
        "getfield_f_wide",
        "getfield_d_wide",
        "getfield0_f_wide",
        "getfield0_d_wide",
        "putfield_f_wide",
        "putfield_d_wide",
        "putfield0_f_wide",
        "putfield0_d_wide",
        "invokevirtual_f_wide",
        "invokevirtual_d_wide",
        "invokestatic_f_wide",
        "invokestatic_d_wide",
        "invokesuper_f_wide",
        "invokesuper_d_wide",
        "invokenative_f_wide",
        "invokenative_d_wide"
/*end[FLOATS]*/
    };
}
