#ifndef __OS_MAIN_H__
#define __OS_MAIN_H__

#ifdef UNIT_TEST
#include "jni_md.h"
#endif  /* UNIT_TEST */

/*if[!MICROBLAZE32_BUILD]*/
typedef union {
  float f;
  unsigned int u;
} float_bits;

typedef union {
  jlong all;
  struct {
    unsigned int low;
    int high;
  }s;
} dwords;

typedef union {
  ujlong all;
    struct {
      unsigned int low;
      unsigned int high;
    }s;
} udwords;

/*
 * Float to 64 bit int transformation based on the LLVM compiler_rt
 * implementation
 */
jlong __fixsfdi(float a){
  float_bits fb;
  int e;

  fb.f = a;
  e = ((fb.u & 0x7F800000) >> 23) - 127;

  if (e < 0)
    return 0;

  jlong s = (int)(fb.u & 0x80000000) >> 31;
  jlong r = (fb.u & 0x007FFFFF) | 0x00800000;

  if (e > 23)
    r <<= (e - 23);
  else
    r >>= (23 - e);

  return (r ^ s) - s;
}

/*
 * Returns: the number of leading 0-bits in a 32 bit integer
 * Precondition: a != 0
 * based on the LLVM compiler_rt implementation
 */
int __clzsi2(int a)
{
  unsigned int x = (unsigned int)a;
  int t = ((x & 0xFFFF0000) == 0) << 4;  /* if (x is small) t = 16 else 0 */
  x >>= 16 - t;       /* x = [0 - 0xFFFF] */
  unsigned int r = t; /* r = [0, 16] */
  /* return r + clz(x) */
  t = ((x & 0xFF00) == 0) << 3;
  x >>= 8 - t;       /* x = [0 - 0xFF] */
  r += t;            /* r = [0, 8, 16, 24] */
  /* return r + clz(x) */
  t = ((x & 0xF0) == 0) << 2;
  x >>= 4 - t;       /* x = [0 - 0xF] */
  r += t;            /* r = [0, 4, 8, 12, 16, 20, 24, 28] */
  /* return r + clz(x) */
  t = ((x & 0xC) == 0) << 1;
  x >>= 2 - t;       /* x = [0 - 3] */
  r += t;            /* r = [0 - 30] and is even */
  /* return r + clz(x) */
/*     switch (x)
 *     {
 *     case 0:
 *         return r + 2;
 *     case 1:
 *         return r + 1;
 *     case 2:
 *     case 3:
 *         return r;
 *     }
 */
  return r + ((2 - x) & -((x & 2) == 0));
}

/*
 * Returns: the number of leading 0-bits in a 64 bit integer
 * Precondition: a != 0
 * based on the LLVM compiler_rt implementation
 */
int __clzdi2(jlong a)
{
  dwords x;
  x.all = a;
  const int f = -(x.s.high == 0);
  return __builtin_clz((x.s.high & ~f) | (x.s.low & f)) +
    (f & ((int)(sizeof(int) * __CHAR_BIT__)));
}

/*
 * Compares two signed 64 bit integers
 * Returns: if (a <  b) returns 0
 *          if (a == b) returns 1
 *          if (a >  b) returns 2
 */
int __cmpdi2(jlong a, jlong b)
{
  dwords x;
  x.all = a;
  dwords y;
  y.all = b;
  if (x.s.high < y.s.high)
    return 0;
  if (x.s.high > y.s.high)
    return 2;
  if (x.s.low < y.s.low)
    return 0;
  if (x.s.low > y.s.low)
    return 2;
  return 1;
}

/*
 * Compares two unsigned 64 bit integers
 * Returns:  if (a <  b) returns 0
 *           if (a == b) returns 1
 *           if (a >  b) returns 2
 */
int __ucmpdi2(ujlong a, ujlong b)
{
  udwords x;
  x.all = a;
  udwords y;
  y.all = b;
  if (x.s.high < y.s.high)
    return 0;
  if (x.s.high > y.s.high)
    return 2;
  if (x.s.low < y.s.low)
    return 0;
  if (x.s.low > y.s.low)
    return 2;
  return 1;
}

/*
 * 64 bit int to float transformation based on the LLVM compiler_rt
 * implementation
 */
float __floatdisf(jlong a)
{
  if (a == 0)
    return 0.0F;
  const unsigned N = sizeof(jlong) * __CHAR_BIT__;
  const jlong s = a >> (N-1);
  a = (a ^ s) - s;
  int sd = N - __builtin_clzll(a);  /* number of significant digits */
  int e = sd - 1;             /* exponent */
  if (sd > __FLT_MANT_DIG__)
  {
    /*  start:  0000000000000000000001xxxxxxxxxxxxxxxxxxxxxxPQxxxxxxxxxxxxxxxxxx
     *  finish: 000000000000000000000000000000000000001xxxxxxxxxxxxxxxxxxxxxxPQR
     *                                                12345678901234567890123456
     *  1 = msb 1 bit
     *  P = bit FLT_MANT_DIG-1 bits to the right of 1
     *  Q = bit FLT_MANT_DIG bits to the right of 1
     *  R = "or" of all bits to the right of Q
     */
    switch (sd)
    {
    case __FLT_MANT_DIG__ + 1:
      a <<= 1;
      break;
    case __FLT_MANT_DIG__ + 2:
      break;
    default:
      a = ((ujlong)a >> (sd - (__FLT_MANT_DIG__+2))) |
        ((a & ((ujlong)(-1) >> ((N + __FLT_MANT_DIG__+2) - sd))) != 0);
    };
    /* finish: */
    a |= (a & 4) != 0;  /* Or P into R */
    ++a;  /* round - this step may add a significant bit */
    a >>= 2;  /* dump Q and R */
    /* a is now rounded to FLT_MANT_DIG or FLT_MANT_DIG+1 bits */
    if (a & ((ujlong)1 << __FLT_MANT_DIG__))
    {
      a >>= 1;
      ++e;
    }
    /* a is now rounded to FLT_MANT_DIG bits */
  }
  else
  {
    a <<= (__FLT_MANT_DIG__ - sd);
    /* a is now rounded to FLT_MANT_DIG bits */
  }
  float_bits fb;
  fb.u = ((unsigned int)s & 0x80000000) |  /* sign */
    ((e + 127) << 23)       |  /* exponent */
    ((unsigned int)a & 0x007FFFFF);   /* mantissa */
  return fb.f;
}

/*
 * 64 bit multiplication based on the LLVM compiler_rt implementation
 */
static jlong __muldsi3(unsigned int a, unsigned int b)
{
  dwords r;
  const int bits_in_word_2 = (int)(sizeof(int) * __CHAR_BIT__) / 2;
  const unsigned int lower_mask = (unsigned int)~0 >> bits_in_word_2;
  r.s.low = (a & lower_mask) * (b & lower_mask);
  unsigned int t = r.s.low >> bits_in_word_2;
  r.s.low &= lower_mask;
  t += (a >> bits_in_word_2) * (b & lower_mask);
  r.s.low += (t & lower_mask) << bits_in_word_2;
  r.s.high = t >> bits_in_word_2;
  t = r.s.low >> bits_in_word_2;
  r.s.low &= lower_mask;
  t += (b >> bits_in_word_2) * (a & lower_mask);
  r.s.low += (t & lower_mask) << bits_in_word_2;
  r.s.high += t >> bits_in_word_2;
  r.s.high += (a >> bits_in_word_2) * (b >> bits_in_word_2);
  return r.all;
}
/* Returns: a * b */
jlong __muldi3(jlong a, jlong b)
{
  dwords x;
  x.all = a;
  dwords y;
  y.all = b;
  dwords r;
  r.all = __muldsi3(x.s.low, y.s.low);
  r.s.high += x.s.high * y.s.low + x.s.low * y.s.high;
  return r.all;
}

/*
 * Returns: the number of trailing 0-bits
 * Precondition: a != 0
 * based on the LLVM compiler_rt implementation
 */
int __ctzsi2(int a)
{
  unsigned int x = (unsigned int)a;
  int t = ((x & 0x0000FFFF) == 0) << 4;  /* if (x has no small bits) t = 16 else 0 */
  x >>= t;           /* x = [0 - 0xFFFF] + higher garbage bits */
  unsigned int r = t;       /* r = [0, 16]  */
  /* return r + ctz(x) */
  t = ((x & 0x00FF) == 0) << 3;
  x >>= t;           /* x = [0 - 0xFF] + higher garbage bits */
  r += t;            /* r = [0, 8, 16, 24] */
  /* return r + ctz(x) */
  t = ((x & 0x0F) == 0) << 2;
  x >>= t;           /* x = [0 - 0xF] + higher garbage bits */
  r += t;            /* r = [0, 4, 8, 12, 16, 20, 24, 28] */
  /* return r + ctz(x) */
  t = ((x & 0x3) == 0) << 1;
  x >>= t;
  x &= 3;            /* x = [0 - 3] */
  r += t;            /* r = [0 - 30] and is even */
  /* return r + ctz(x) */
/*  The branch-less return statement below is equivalent
 *  to the following switch statement:
 *     switch (x)
 *    {
 *     case 0:
 *         return r + 2;
 *     case 2:
 *         return r + 1;
 *     case 1:
 *     case 3:
 *         return r;
 *     }
 */
  return r + ((2 - (x >> 1)) & -((x & 1) == 0));
}

/*
 * 64 bit division and modulo based on the LLVM compiler_rt
 * implementation
 *
 * Effects: if rem != 0, *rem = a % b
 * Returns: a / b
 */
ujlong __udivmoddi4(ujlong a, ujlong b, ujlong* rem)
{
  const unsigned n_uword_bits = sizeof(unsigned int) * __CHAR_BIT__;
  const unsigned n_udword_bits = sizeof(ujlong) * __CHAR_BIT__;
  udwords n;
  n.all = a;
  udwords d;
  d.all = b;
  udwords q;
  udwords r;
  unsigned sr;
  /* special cases, X is unknown, K != 0 */
  if (n.s.high == 0)
  {
    if (d.s.high == 0)
    {
      /* 0 X
       * ---
       * 0 X
       */
      if (rem)
        *rem = n.s.low % d.s.low;
      return n.s.low / d.s.low;
    }
    /* 0 X
     * ---
     * K X
     */
    if (rem)
      *rem = n.s.low;
    return 0;
  }
  /* n.s.high != 0 */
  if (d.s.low == 0)
  {
    if (d.s.high == 0)
    {
      /* K X
       * ---
       * 0 0
       */
      if (rem)
        *rem = n.s.high % d.s.low;
      return n.s.high / d.s.low;
    }
    /* d.s.high != 0 */
    if (n.s.low == 0)
    {
      /* K 0
       * ---
       * K 0
       */
      if (rem)
      {
        r.s.high = n.s.high % d.s.high;
        r.s.low = 0;
        *rem = r.all;
      }
      return n.s.high / d.s.high;
    }
    /* K K
     * ---
     * K 0
     */
    if ((d.s.high & (d.s.high - 1)) == 0)     /* if d is a power of 2 */
    {
      if (rem)
      {
        r.s.low = n.s.low;
        r.s.high = n.s.high & (d.s.high - 1);
        *rem = r.all;
      }
      return n.s.high >> __builtin_ctz(d.s.high);
    }
    /* K K
     * ---
     * K 0
     */
    sr = __builtin_clz(d.s.high) - __builtin_clz(n.s.high);
    /* 0 <= sr <= n_uword_bits - 2 or sr large */
    if (sr > n_uword_bits - 2)
    {
      if (rem)
        *rem = n.all;
      return 0;
    }
    ++sr;
    /* 1 <= sr <= n_uword_bits - 1 */
    /* q.all = n.all << (n_udword_bits - sr); */
    q.s.low = 0;
    q.s.high = n.s.low << (n_uword_bits - sr);
    /* r.all = n.all >> sr; */
    r.s.high = n.s.high >> sr;
    r.s.low = (n.s.high << (n_uword_bits - sr)) | (n.s.low >> sr);
  }
  else  /* d.s.low != 0 */
  {
    if (d.s.high == 0)
    {
      /* K X
       * ---
       * 0 K
       */
      if ((d.s.low & (d.s.low - 1)) == 0)     /* if d is a power of 2 */
      {
        if (rem)
          *rem = n.s.low & (d.s.low - 1);
        if (d.s.low == 1)
          return n.all;
        unsigned sr = __builtin_ctz(d.s.low);
        q.s.high = n.s.high >> sr;
        q.s.low = (n.s.high << (n_uword_bits - sr)) | (n.s.low >> sr);
        return q.all;
      }
      /* K X
       * ---
       *0 K
       */
      sr = 1 + n_uword_bits + __builtin_clz(d.s.low) - __builtin_clz(n.s.high);
      /* 2 <= sr <= n_udword_bits - 1
       * q.all = n.all << (n_udword_bits - sr);
       * r.all = n.all >> sr;
       * if (sr == n_uword_bits)
       * {
       *     q.s.low = 0;
       *     q.s.high = n.s.low;
       *     r.s.high = 0;
       *     r.s.low = n.s.high;
       * }
       * else if (sr < n_uword_bits)  // 2 <= sr <= n_uword_bits - 1
       * {
       *     q.s.low = 0;
       *     q.s.high = n.s.low << (n_uword_bits - sr);
       *     r.s.high = n.s.high >> sr;
       *     r.s.low = (n.s.high << (n_uword_bits - sr)) | (n.s.low >> sr);
       * }
       * else              // n_uword_bits + 1 <= sr <= n_udword_bits - 1
       * {
       *     q.s.low = n.s.low << (n_udword_bits - sr);
       *     q.s.high = (n.s.high << (n_udword_bits - sr)) |
       *              (n.s.low >> (sr - n_uword_bits));
       *     r.s.high = 0;
       *     r.s.low = n.s.high >> (sr - n_uword_bits);
       * }
       */
      q.s.low =  (n.s.low << (n_udword_bits - sr)) &
        ((int)(n_uword_bits - sr) >> (n_uword_bits-1));
      q.s.high = ((n.s.low << ( n_uword_bits - sr)) &
                  ((int)(sr - n_uword_bits - 1) >> (n_uword_bits-1))) |
        (((n.s.high << (n_udword_bits - sr)) |
          (n.s.low >> (sr - n_uword_bits))) &
         ((int)(n_uword_bits - sr) >> (n_uword_bits-1)));
      r.s.high = (n.s.high >> sr) &
        ((int)(sr - n_uword_bits) >> (n_uword_bits-1));
      r.s.low =  ((n.s.high >> (sr - n_uword_bits)) &
                  ((int)(n_uword_bits - sr - 1) >> (n_uword_bits-1))) |
        (((n.s.high << (n_uword_bits - sr)) |
          (n.s.low >> sr)) &
         ((int)(sr - n_uword_bits) >> (n_uword_bits-1)));
    }
    else
    {
      /* K X
       * ---
       * K K
       */
      sr = __builtin_clz(d.s.high) - __builtin_clz(n.s.high);
      /* 0 <= sr <= n_uword_bits - 1 or sr large */
      if (sr > n_uword_bits - 1)
      {
        if (rem)
          *rem = n.all;
        return 0;
      }
      ++sr;
      /* 1 <= sr <= n_uword_bits */
      /*  q.all = n.all << (n_udword_bits - sr); */
      q.s.low = 0;
      q.s.high = n.s.low << (n_uword_bits - sr);
      /* r.all = n.all >> sr;
       * if (sr < n_uword_bits)
       * {
       *     r.s.high = n.s.high >> sr;
       *     r.s.low = (n.s.high << (n_uword_bits - sr)) | (n.s.low >> sr);
       * }
       * else
       * {
       *     r.s.high = 0;
       *     r.s.low = n.s.high;
       * }
       */
      r.s.high = (n.s.high >> sr) &
        ((int)(sr - n_uword_bits) >> (n_uword_bits-1));
      r.s.low = (n.s.high << (n_uword_bits - sr)) |
        ((n.s.low >> sr) &
         ((int)(sr - n_uword_bits) >> (n_uword_bits-1)));
    }
  }
  /* Not a special case
   * q and r are initialized with:
   * q.all = n.all << (n_udword_bits - sr);
   * r.all = n.all >> sr;
   * 1 <= sr <= n_udword_bits - 1
   */
  unsigned int carry = 0;
  for (; sr > 0; --sr)
  {
    /* r:q = ((r:q)  << 1) | carry */
    r.s.high = (r.s.high << 1) | (r.s.low  >> (n_uword_bits - 1));
    r.s.low  = (r.s.low  << 1) | (q.s.high >> (n_uword_bits - 1));
    q.s.high = (q.s.high << 1) | (q.s.low  >> (n_uword_bits - 1));
    q.s.low  = (q.s.low  << 1) | carry;
    /* carry = 0;
     * if (r.all >= d.all)
     * {
     *      r.all -= d.all;
     *      carry = 1;
     * }
     */
    const jlong s = (jlong)(d.all - r.all - 1) >> (n_udword_bits - 1);
    carry = s & 1;
    r.all -= d.all & s;
  }
  q.all = (q.all << 1) | carry;
  if (rem)
    *rem = r.all;
  return q.all;
}

/*
 * 64 bit int division based on the LLVM compiler_rt implementation
 */
jlong __divdi3(jlong a, jlong b)
{
  const int bits_in_dword_m1 = (int)(sizeof(jlong) * __CHAR_BIT__) - 1;
  jlong s_a = a >> bits_in_dword_m1;           /* s_a = a < 0 ? -1 : 0 */
  jlong s_b = b >> bits_in_dword_m1;           /* s_b = b < 0 ? -1 : 0 */
  a = (a ^ s_a) - s_a;                         /* negate if s_a == -1 */
  b = (b ^ s_b) - s_b;                         /* negate if s_b == -1 */
  s_a ^= s_b;                                  /*sign of quotient */
  /* negate if s_a == -1 */
  return (__udivmoddi4((ujlong)a, (ujlong)b, (ujlong*)0) ^ s_a) - s_a;
}

/*
 * 64 bit int modulo based on the LLVM compiler_rt implementation
 */
jlong __moddi3(jlong a, jlong b)
{
  const int bits_in_dword_m1 = (int)(sizeof(jlong) * __CHAR_BIT__) - 1;
  jlong s = b >> bits_in_dword_m1;   /* s = b < 0 ? -1 : 0 */
  b = (b ^ s) - s;                   /* negate if s == -1 */
  s = a >> bits_in_dword_m1;         /* s = a < 0 ? -1 : 0 */
  a = (a ^ s) - s;                   /* negate if s == -1 */
  jlong r;
  __udivmoddi4((ujlong)a, (ujlong)b, (ujlong*)&r);
  return (r ^ s) - s;                /* negate if s == -1 */
}
/*end[MICROBLAZE32_BUILD]*/

#ifdef UNIT_TEST
#define STRINGIFY(x) #x
#define TOSTRING(x) STRINGIFY(x)
#define assert(x) \
  if (!(x)) {\
    printf("Assert failed: ");               \
    printf(TOSTRING(x)); \
    printf("\n"); \
  }

int main()
{
  long long a = 0xAAAAAAAAAAAAAAAALL;
  long long b = 0x00000000BBBBBBBBLL;
  long long c = 0x000000000000BBBBLL;
  long long d = 0x000000BBBBBBBBBBLL;
  long long e = 0x1122334455667788LL;
  long long f = 0x0000004455667788LL;
  long long g = 0x1122330000000000LL;

  assert(e==e && "64bit equality T");
  assert(e!=f && "64bit equality F");
  assert(e!=g && "64bit equality F2");
  assert(f!=g && "64bit equality F3");

  long long mod_ll = __moddi3(a, b);
  assert(mod_ll==0xFFFFFFFFCCCCCCCCLL && "mod LL");

  long div_l = (long)__divdi3(a,b);
  assert(div_l==0XFFFFFFFF8BA2E8BALL && "div b L");

  long long div_ll = __divdi3(a,c);
  assert(div_ll==0xFFFF8BA2745CA2E9LL && "div c LL");

  mod_ll = __moddi3(a,c);
  assert(mod_ll==0xFFFFFFFFFFFF7777LL && "mod c LL");

  long mul_ll = __muldi3(c, d);
  assert(mul_ll==0x89AB444443BA99LL && "mul c d LL");

  int ia = 0xF000;
  int trailing = __ctzsi2(ia);
  assert(trailing==12 && "Trailing zero bits");

  return 0;
}

#endif  /* UNIT_TEST */

#endif /* __OS_MAIN_H__ */
