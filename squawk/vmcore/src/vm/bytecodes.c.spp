/*
 * Copyright 2004-2010 Sun Microsystems, Inc. All Rights Reserved.
 * Copyright 2011 Oracle Corporation. All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER
 *
 * This code is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2
 * only, as published by the Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License version 2 for more details (a copy is
 * included in the LICENSE file that accompanied this code).
 *
 * You should have received a copy of the GNU General Public License
 * version 2 along with this work; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *
 * Please contact Oracle Corporation, 500 Oracle Parkway, Redwood
 * Shores, CA 94065 or visit www.oracle.com if you need additional
 * information or have any questions.
 */

/*if[MACROIZE]*/
#define   nextbytecode() continue
/*else[MACROIZE]*/
//#define nextbytecode() return
//INLINE int     getArrayLength(Address oop);
//INLINE Address getMP();
/*end[MACROIZE]*/

static int             MethodHeader_minfoValue1_L(Address);
static int             MethodHeader_minfoValue2_L(Address);
static int             MethodHeader_minfoValue3_L(Address);
static int             MethodHeader_getOffsetToLastMinfoByte0_LII(Address oop, int p, int b0);

static int             VM_lookup_b(int, Address);
static int             VM_lookup_i(int, Address);
static int             VM_lookup_s(int, Address);
INLINE int             VM_arrayOopStoreCheck(Address, int, Address);
INLINE int             VM_findSlot(Address, Address, int);
INLINE boolean         VM_instanceof(Address, Address);
static Address         Isolate_getClassStateForInterpreter_L(Address, Address);

/*-----------------------------------------------------------------------*\
 *                      Class state cache managemant                     *
 *                                                                       *
 *   Even when compiling the class state lookup code into C, this cache  *
 *   adds about 10% performance for static variable accesses in common   *
 *   case.                                                               *
\*-----------------------------------------------------------------------*/

#ifdef INTERPRETER_STATS
#define updateCachedClassAccesses() cachedClassAccesses_g++
#define updateCachedClassHits() cachedClassHits_g++
#else
#define updateCachedClassAccesses()
#define updateCachedClassHits()
#endif /* INTERPRETER_STATS */

/**
 * Add a cached class state association.
 *
 * @param klass the klass
 * @param state the klass state

 * @return its class state or null if not found
 */
/*MAC*/ void addClassState(Address $klass, Address $state) {
	int i;
	for (i = CLASS_CACHE_SIZE-1 ; i > 0  ; --i) {
		cachedClass_g[i]      = cachedClass_g[i-1];
		cachedClassState_g[i] = cachedClassState_g[i-1];
	}
	cachedClass_g[0]      = $klass;
	cachedClassState_g[0] = $state;
}

/**
 * Get a cached class state.
 *
 * @param klass the klass
 * @return its class state or null if not found
 */
Address getClassState(Address klass) {
	int i;
	updateCachedClassAccesses();
	for (i = 0 ; i < CLASS_CACHE_SIZE ; i++) {
		if (cachedClass_g[i] == klass) {
			updateCachedClassHits();
			return cachedClassState_g[i];
		}
	}
	return null;
}

INLINE Address VM_getClassStateREAL(Address klass) {
	Address cs = getClassState(klass);
	if (cs != null) {
		return cs;
	}
	return Isolate_getClassStateForInterpreter_L(com_sun_squawk_VM_currentIsolate, klass);
}

/**
 * Test to see if a class needs initializing.
 *
 * @param klass the klass
 * @return true if it does.
 */
/*MAC*/ boolean needsInitializing(Address $klass) {
	if (com_sun_squawk_Klass_modifiers($klass) & com_sun_squawk_Modifier_KLASS_MUSTCLINIT) {
		return VM_getClassStateREAL($klass) == null;
	}
	return false;
}

/**
 * Invalidate the class state cache.
 *
 * @return true if it was already invalid.
 */
/*MAC*/ boolean invalidateClassStateCache() {
	int i;
	UWord res = 0;
	for (i = 0 ; i < CLASS_CACHE_SIZE ; i++) {
		res |= (UWord)cachedClass_g[i];
		cachedClass_g[i] = null;
	}
	return res == 0;
}

/*-----------------------------------------------------------------------*\
 *                           Instruction decoding                        *
 \*-----------------------------------------------------------------------*/

/**
 * Fetch a byte from ip.
 *
 * @return the value
 */
/*DEF*/ signed char fetchByte() {
	return getByteTyped(ip_g++, 0, AddressType_BYTECODE);
}

/**
 * Fetch an unsigned byte from from ip.
 *
 * @return the value
 */
/*DEF*/ unsigned char fetchUByte() {
	return getUByteTyped(ip_g++, 0, AddressType_BYTECODE);
}

/**
 * Fetch a short from ip and place in fparm.
 */
/*DEF*/ void fetchShort() {
	if (PLATFORM_UNALIGNED_LOADS) {
		fparm = getShortTyped(ip_g, 0, AddressType_BYTECODE);
		ip_g += sizeof(short);
	} else {
		if (PLATFORM_BIG_ENDIAN) {
			int b1 = fetchByte();
			int b2 = fetchUByte();
			fparm = (b1 << 8) | b2;
		} else {
			int b1 = fetchUByte();
			int b2 = fetchByte();
			fparm = (b2 << 8) | b1;
		}
	}
}

/**
 * Fetch an unsigned short from ip and place in fparm.
 */
/*DEF*/ void fetchUShort() {
	if (PLATFORM_UNALIGNED_LOADS) {
		fparm = getUShortTyped(ip_g, 0, AddressType_BYTECODE);
		ip_g += sizeof(unsigned short);
	} else {
		int b1 = fetchUByte();
		int b2 = fetchUByte();
		if (PLATFORM_BIG_ENDIAN) {
			fparm = (b1 << 8) | b2;
		} else {
			fparm = (b2 << 8) | b1;
		}
	}
}

/**
 * Fetch an int from ip and place in fparm.
 */
/*DEF*/ void fetchInt() {
	if (PLATFORM_UNALIGNED_LOADS) {
		fparm = getIntTyped(ip_g, 0, AddressType_BYTECODE);
		ip_g += sizeof(int);
	} else {
		int b1 = fetchUByte();
		int b2 = fetchUByte();
		int b3 = fetchUByte();
		int b4 = fetchUByte();
		if (PLATFORM_BIG_ENDIAN) {
			fparm = (b1 << 24) | (b2 << 16) | (b3 << 8) | b4;
		} else {
			fparm = (b4 << 24) | (b3 << 16) | (b2 << 8) | b1;
		}
	}
}

/**
 * Fetch a long from ip and place in flparm.
 *
 * @return the value
 */
/*DEF*/ void fetchLong() {
	if (PLATFORM_UNALIGNED_64_LOADS) {
		flparm = getLongTyped(ip_g, 0, AddressType_BYTECODE);
		ip_g += sizeof(jlong);
	} else {
		flparm = getUnalignedLong(ip_g, 0);
		ip_g += sizeof(jlong);
	}
}


/*-----------------------------------------------------------------------*\
 *                          Operand stack                                *
 \*-----------------------------------------------------------------------*/

#if ASSUME
/**
 * Asserts that the stack pointer is within the current stack and decrementing it
 * won't overflow the stack limit.
 */
/*MAC*/ void checkPush() {
/*if[REVERSE_PARAMETERS]*/
	/* if (loeq(sp_g, sl_g)) fprintf(stderr, format("sp_g=%A, sl_g=%A, ss_g=%A\n"), sp_g, sl_g, ss_g); */
	assume(sp_g > sl_g);
	assume(getUWord(ss_g, SC_guard) == 0);
	if (ss_g == com_sun_squawk_VMThread_serviceStack) {
		assume(loeq(sp_g, Address_add(com_sun_squawk_VMThread_serviceStack, SERVICE_CHUNK_SIZE)));
	} else {
		assume(loeq(sp_g, &ss_g[getArrayLength(ss_g)]));
	}
/*end[REVERSE_PARAMETERS]*/
}
#else
#define checkPush()
#endif /* ASSUME */

/**
 * Pushes an int value onto the runtime stack.
 */
/*MAC*/ void pushInt(int $value) {
/*if[REVERSE_PARAMETERS]*/
	checkPush();
	setUWordTyped(--sp_g, 0, AddressType_INT, (UWord)$value);
/*else[REVERSE_PARAMETERS]*/
//	setUWordTyped(sp_g++, 0, AddressType_INT, (UWord)$value);
//	checkPush();
/*end[REVERSE_PARAMETERS]*/
}

/**
 * Pops an int value from the runtime stack.
 */
/*MAC*/ int popInt() {
/*if[REVERSE_PARAMETERS]*/
	return (int)getUWordTyped(sp_g++, 0, AddressType_INT);
/*else[REVERSE_PARAMETERS]*/
//	return (int)getUWordTyped(--sp_g, 0, AddressType_INT);
/*end[REVERSE_PARAMETERS]*/
}

/**
 * Pushes an address onto the runtime stack -- always downwards.
 */
/*MAC*/ void downPushAddress(Address $value) {
	checkPush();
	setObject(--sp_g, 0, $value);
}

/**
 * Pushes an address onto the runtime stack.
 */
/*MAC*/ void pushAddress(Address $value) {
/*if[REVERSE_PARAMETERS]*/
	checkPush();
	setObject(--sp_g, 0, $value);
/*else[REVERSE_PARAMETERS]*/
//	setObject(sp_g++, 0, $value);
//	checkPush();
/*end[REVERSE_PARAMETERS]*/
}

/**
 * Pops an address from the runtime stack.
 */
/*MAC*/ Address popAddress() {
/*if[REVERSE_PARAMETERS]*/
	return getObject(sp_g++, 0);
/*else[REVERSE_PARAMETERS]*/
//	return getObject(--sp_g, 0);
/*end[REVERSE_PARAMETERS]*/
}

/**
 * Peeks the value on the top of the runtime stack.
 */
/*MAC*/ UWord peek() {
	return getUWordTyped(sp_g, 0, AddressType_ANY);
}

/**
 * Pushes a jlong value onto the runtime stack.
 */
#if SQUAWK_64
/*MAC*/ void pushLong(jlong $value) {
/*if[REVERSE_PARAMETERS]*/
	checkPush();
	setLong(--sp_g, 0, $value);
	assumeInterp($value == getLong(sp_g, 0));
/*else[REVERSE_PARAMETERS]*/
//	setLong(sp_g++, 0, $value);
//	checkPush();
//	assumeInterp($value == getLong(sp_g, -1));
/*end[REVERSE_PARAMETERS]*/
}
#else
/*MAC*/ void pushLong(jlong $value) {
/*if[REVERSE_PARAMETERS]*/
	checkPush();
	--sp_g;
	setLongAtWord(--sp_g, 0, $value);
	assumeInterp($value == getLongAtWord(sp_g, 0));
/*else[REVERSE_PARAMETERS]*/
//	setLongAtWord(sp_g++, 0, $value);
//	sp_g++;
//	checkPush();
//	assumeInterp($value == getLongAtWord(sp_g, -2));
/*end[REVERSE_PARAMETERS]*/
}
#endif

/**
 * Pops a jlong value from the runtime stack.
 */
#if SQUAWK_64
/*MAC*/ jlong popLong() {
/*if[REVERSE_PARAMETERS]*/
	return getLong(sp_g++, 0);
/*else[REVERSE_PARAMETERS]*/
//	return getLong(--sp_g, 0);
/*end[REVERSE_PARAMETERS]*/
}
#else
/*MAC*/ jlong popLong() {
/*if[REVERSE_PARAMETERS]*/
	return getLongAtWord(sp_g = sp_g + 2, -2);
/*else[REVERSE_PARAMETERS]*/
//	return getLongAtWord(sp_g = sp_g - 2, 0);
/*end[REVERSE_PARAMETERS]*/
}
#endif

/**
 * Pops a UWord from the runtime stack.
 */
/*MAC*/ UWord popWord() {
/*if[REVERSE_PARAMETERS]*/
	return getUWord(sp_g++, 0);
/*else[REVERSE_PARAMETERS]*/
//	return getUWord(--sp_g, 0);
/*end[REVERSE_PARAMETERS]*/
}

/**
 * Pushes a UWord to the runtime stack.
 */
/*MAC*/ void pushWord(UWord $value) {
/*if[REVERSE_PARAMETERS]*/
	checkPush();
	setUWord(--sp_g, 0, $value);
/*else[REVERSE_PARAMETERS]*/
//	setUWord(sp_g++, 0, $value);
//	checkPush();
/*end[REVERSE_PARAMETERS]*/
}

#if TYPEMAP
/**
 * Pushes a UWord onto the runtime stack, recording the type of the value pushed.
 */
/*MAC*/ void pushAsType(UWord $value, char $type) {
/*if[REVERSE_PARAMETERS]*/
	checkPush();
	setUWordTyped(--sp_g, 0, $type, $value);
/*else[REVERSE_PARAMETERS]*/
//	setUWordTyped(sp_g++, 0, $type, $value);
//	checkPush();
/*end[REVERSE_PARAMETERS]*/
}

/**
 * Pops a UWord from the runtime stack, checking that its type matches a given type.
 */
/*MAC*/ UWord popAsType(char $type) {
/*if[REVERSE_PARAMETERS]*/
	return getUWordTyped(sp_g++, 0, $type);
/*else[REVERSE_PARAMETERS]*/
//	return getUWordTyped(--sp_g, 0, $type);
/*end[REVERSE_PARAMETERS]*/
}
#else
#define pushAsType(value, type) pushWord(value)
#define popAsType(type) popWord()
#endif /* TYPEMAP */

/*-----------------------------------------------------------------------*\
 *                          Bytecode dispatching                         *
 \*-----------------------------------------------------------------------*/

/**
 * Prefix for bytecode with no parameter.
 */
/*DEF*/ void iparmNone() {
}

/**
 * Prefix for bytecode with a byte parameter.
 */
/*DEF*/ void iparmByte() {
	iparm_g = fetchByte();
}

/**
 * Prefix for bytecode with an unsigned byte parameter.
 */
/*DEF*/ void iparmUByte() {
	iparm_g = fetchUByte();
}

/**
 * Add 256 to the next unsigned byte and jump to that bytecode execution.
 */
/*DEF*/ void do_escape() {
	opcode = fetchUByte() + 256;
	goto next;
}

/**
 * Or the (parameter<<8) into the value of the next bytecode and then
 * dispatch to the wide version of the opcode.
 */
/*DEF*/ void do_wide_n(int $n) {
	opcode = fetchUByte() + OPC_Properties_WIDE_DELTA;
	iparm_g  = fetchUByte() | ($n<<8);
	goto next;
}

/**
 * Load the inlined short as the value of the next bytecode and then
 * dispatch to the wide version of the opcode.
 */
/*DEF*/ void do_wide_short() {
	int fparm;
	opcode = fetchUByte() + OPC_Properties_WIDE_DELTA;
	fetchShort();
	iparm_g = fparm;
	goto next;
}

/**
 * Load the inlined int as the value of the next bytecode and then
 * dispatch to the wide version of the opcode.
 */
/*DEF*/ void do_wide_int() {
	int fparm;
	opcode = fetchUByte() + OPC_Properties_WIDE_DELTA;
	fetchInt();
	iparm_g = fparm;
	goto next;
}

/**
 * Or the (parameter<<8) in to the value of the next bytecode and then
 * dispatch to the wide version of the opcode.
 */
/*DEF*/ void do_escape_wide_n(int $n) {
	opcode = fetchUByte() + 256 + OPC_Properties_ESCAPE_WIDE_DELTA;
	iparm_g  = fetchUByte() | ($n<<8);
	goto next;
}

/**
 * Load the inlined short as the value of the next bytecode and then
 * dispatch to the wide version of the opcode.
 */
/*DEF*/ void do_escape_wide_short() {
	int fparm;
	opcode = fetchUByte() + 256 + OPC_Properties_ESCAPE_WIDE_DELTA;
	fetchShort();
	iparm_g = fparm;
	goto next;
}

/**
 * Load the inlined int as the value of the next bytecode and then
 * dispatch to the wide version of the opcode.
 */
/*DEF*/ void do_escape_wide_int() {
	int fparm;
	opcode = fetchUByte() + 256 + OPC_Properties_ESCAPE_WIDE_DELTA;
	fetchInt();
	iparm_g = fparm;
	goto next;
}


/*-----------------------------------------------------------------------*\
 *                             Access to data                            *
 \*-----------------------------------------------------------------------*/

/**
 * Gets a local variable ignoring the typemap.
 *
 * @param n int index to the local variable
 * @return the value
 */
/*MAC*/ UWord peekLocal(int $n) {
	return getUWordTyped(fp_g, FP_local0 - $n, AddressType_ANY);
}

/**
 * Gets a local variable.
 *
 * @param n int index to the local variable
 * @return the value
 */
/*MAC*/ UWord getLocal(int $n) {
	return getUWordTyped(fp_g, FP_local0 - $n, getMutationType());
}

/**
 * Sets a local variable.
 *
 * @param n int index to the local variable
 * @param value the value to set
 */
/*MAC*/ void setLocal(int $n, UWord $value) {
	setUWordTyped(fp_g, FP_local0 - $n, getMutationType(), $value);
}

/**
 * Gets a local jlong variable.
 *
 * @param n int index to the local variable
 * @return the value
 */
/*MAC*/ jlong getLocalLong(int $n) {
	return getLongAtWord(fp_g, FP_local0 - $n);
}

/**
 * Sets a local variable.
 *
 * @param n int index to the local variable
 * @param value the value to set
 */
/*MAC*/ void setLocalLong(int $n, jlong $value) {
	setLongAtWord(fp_g, FP_local0 - $n, $value);
}

/**
 * Gets a parameter word.
 *
 * @param n int index to the local variable
 * @return the value
 */
/*MAC*/ UWord getParmTyped(int $n, char $type) {
	return getUWordTyped(fp_g, FP_parm0 + $n, $type);
}

/**
 * Gets a parameter word.
 *
 * @param n int index to the local variable
 * @return the value
 */
/*MAC*/ UWord getParm(int $n) {
	return getParmTyped($n, getMutationType());
}

/**
 * Sets a parameter word.
 *
 * @param n int index to the local variable
 * @param value the value to set
 */
/*MAC*/ void setParm(int $n, UWord $value) {
	setUWordTyped(fp_g, FP_parm0 + $n, getMutationType(), $value);
}

/**
 * Gets a jlong parameter word.
 *
 * @param n int index to the local variable
 * @return the value
 */
/*MAC*/ jlong getParmLong(int $n) {
	return getLongAtWord(fp_g, FP_parm0 + $n);

}

/**
 * Sets a jlong parameter word.
 *
 * @param n int index to the local variable
 * @param value the value to set
 */
/*MAC*/ void setParmLong(int $n, jlong $value) {
	setLongAtWord(fp_g, FP_parm0 + $n, $value);
}

#if ASSUME
/*DEF*/ void boundsAssume(Address $oop, int $index) {
	assume($oop);
	/* use the unsigned bounds check trick: */
	assume((unsigned int) $index < (unsigned int)getArrayLength($oop));
}
#else
/*DEF*/ void boundsAssume(Address $oop, int $index) {}
#endif /* ASSUME */


/*DEF*/ void boundsAssumeAlways(Address $oop, int $index) {
	assumeAlways($oop);
	/* use the unsigned bounds check trick: */
	assumeAlways((unsigned int) $index < (unsigned int)getArrayLength($oop));
}

/*-----------------------------------------------------------------------*\
 *                             Utility code                              *
 \*-----------------------------------------------------------------------*/

/**
 * Gets the current method pointer.
 */
/*MAC*/ Address getMP() {
	return getObject(fp_g, FP_method);
}

/**
 * Gets the current class pointer.
 */
/*MAC*/ Address getCP() {
	return getObject(getMP(), HDR_methodDefiningClass);
}

/**
 * Gets the object specified by an index from the class of the currently executing method.
 *
 * @param  index the index of the object
 * @return the object
 */
/*MAC*/ Address getKlassObject(int $index) {
	return ((Address *)com_sun_squawk_Klass_objects(getCP()))[$index];
}

/**
 * Gets the length of an array object.
 *
 * @param  oop the pointer to the array.
 * @return the length
 */
/*MAC*/ int getArrayLength(Address $oop) {
	assume((int)(getUWord($oop, HDR_length) >> 2) >= 0);
	return (int)(getUWord($oop, HDR_length) >> 2);
}

/**
 * Gets the static method specified by an index from the class.
 *
 * @param  index the index of the method
 * @return the method
 */
/*MAC*/ Address getStaticMethod(Address $cls, int $index) {
	Address stable;
	assume($cls);
	stable = com_sun_squawk_Klass_staticMethods($cls);
	assume(stable);
	assume((unsigned int)$index < (unsigned int)getArrayLength(stable));
	return ((Address *)stable)[$index];
}

/**
 * Gets the virtual method specified by an index from the class.
 *
 * @param index the index of the method
 * @return the method
 */
/*MAC*/ Address getVirtualMethod(Address $cls, int $index) {
	Address vtable;
	assume($cls);
	vtable = com_sun_squawk_Klass_virtualMethods($cls);
	assume((unsigned int)$index < (unsigned int)getArrayLength(vtable));
	return ((Address *)vtable)[$index];
}

/**
 * Sets the length of an array object.
 *
 * @param oop the pointer to the array
 * @param size the length
 * @return false if length was too large
 */
/*MAC*/ boolean setArrayLength(Address $oop, int $size) {
	assume($size >= 0);
	if ($size > 0x3FFFFFF) {
		return false;
	}
	setUWord($oop, HDR_length, ($size << HDR_headerTagBits) | HDR_arrayHeaderTag);
	return true;
}

/**
 * Gets the Klass or the ObjectAssociation of an object.
 *
 * @param  oop the pointer to the object.
 * @return the Klass ot the ObjectAssociation
 */
#if ASSUME
/*MAC*/ Address getClassOrAssociation(Address $oop) {
	/* Catches an attempt to dereference a forwarding pointer */
	assume(com_sun_squawk_GC_collecting || ((UWord)getObject($oop, HDR_klass) & HDR_headerTagMask) == 0);
	return getObject($oop, HDR_klass);
}
#else
/*MAC*/ Address getClassOrAssociation(Address $oop) {
	return getObject($oop, HDR_klass);
}
#endif
/**
 * Given a klass or an association, deerefence the self field
 * to return the actual Klass.
 *
 * @param the Klass or the ObjectAssociation
 * @return the Klass, or the klass refered to by the association
 */
/*MAC*/ Address associationToKlass(Address $oop) {
	return com_sun_squawk_Klass_self($oop);
}

/**
 * Gets the class of an object.
 *
 * @param  oop the pointer to the object.
 * @return the class
 */
/*MAC*/ Address getClass(Address $oop) {
	return com_sun_squawk_Klass_self(getClassOrAssociation($oop));
}

/*
 * Decodes a counter from the minfo area.
 *
 * The routines are translated from Java to C, and are definedin in vm2c.c.spp
 */

/**
 * Gets the b0 byte of the method header.
 *
 * @param mp the method pointer
 * @return the value
 */
/*MAC*/ int getb0(Address $mp) {
	return getUByte($mp, HDR_methodInfoStart);
}

/**
 * Gets the b1 byte of the method header.
 *
 * @param mp the method pointer
 * @return the value
 */
/*MAC*/ int getb1(Address $mp) {
	return getUByte($mp, HDR_methodInfoStart - 1);
}

/**
 * Decode the stack count.
 *
 * @param b0 the first byte
 * @param b1 the second byte
 * @return the value
 */
/*MAC*/ int decodeStackCount(int $b0, int $b1) {
	return $b1 & 0x1F;
}

/**
 * Decode the stack count.
 *
 * @param b0 the first byte
 * @param b1 the second byte
 * @return the value
 */
/*MAC*/ int decodeLocalCount(int $b0, int $b1) {
	return ((($b0 << 8) | $b1) >> 5) & 0x1F;
}

/**
 * Decode the Parm count.
 *
 * @param b0 the first byte
 * @return the value
 */
/*MAC*/ int decodeParmCount(int $b0) {
	return $b0 >> 2;
}

/**
 * Gets the number of stack words used by a method.
 *
 * @param mp the method pointer
 * @return the count
 */
/*MAC*/ int getStackCount(Address $mp) {
	int b0 = getb0($mp);
	if (b0 < 128) {
		int b1 = getb1($mp);
		return decodeStackCount(b0, b1);
	} else {
		return MethodHeader_minfoValue1_L($mp);
	}
}

/**
 * Gets the number of local words used by a method.
 *
 * @param mp the method pointer
 * @return the count
 */
/*MAC*/ int getLocalCount(Address $mp) {
	int b0 = getb0($mp);
	if (b0 < 128) {
		int b1 = getb1($mp);
		return decodeLocalCount(b0, b1);
	} else {
		return MethodHeader_minfoValue2_L($mp);
	}
}

/**
 * Gets the number of parameter words used by a method.
 *
 * @param mp the method pointer
 * @return the count
 */
/*MAC*/ int getParmCount(Address $mp) {
	int b0 = getb0($mp);
	if (b0 < 128) {
		return decodeParmCount(b0);
	} else {
		return MethodHeader_minfoValue3_L($mp);
	}
}

/**
 * Get the offset to the last byte of the Minfo area.
 *
 * @param np the pointer to the method
 * @return the length in bytes
 */
/*MAC*/ int getOffsetToLastMinfoByte(Address $mp) {
	int p = HDR_methodInfoStart;
	int b0 = getUByte($mp, p--);
	if (b0 < 128) {
		return p;
	} else {
		return MethodHeader_getOffsetToLastMinfoByte0_LII($mp, p, b0);
	}
}

#ifdef _MSC_VER
#pragma auto_inline(off)
#endif

/**
 * Gets the number of local words plus stack words used by a method.
 *
 * @param mp the method pointer
 * @return the count
 */
int getLocalCountPlusStackCountIfNotReversingParms(Address mp) {
	int res = getLocalCount(mp);
/*if[REVERSE_PARAMETERS]*/
/*else[REVERSE_PARAMETERS]*/
//	res += getStackCount(mp);
/*end[REVERSE_PARAMETERS]*/
	return res;
}

#ifdef _MSC_VER
#pragma auto_inline(on)
#endif

/**
 * Clears the operand stack given the number of locals in the current method.
 *
 * @param delta the number of words to adjust by
 */
/*MAC*/ void resetStackPointerFromDelta(int $delta) {
	sp_g = fp_g - $delta + 1; /* + 1 so sp points one word before first stack word */
}

/**
 * Clears the operand stack.
 */
/*MAC*/ void resetStackPointer() {
	Address mp = getMP();
	int delta;
	int b0 = getb0(mp);
	if (b0 < 128) {
		int b1 = getb1(mp);
/*if[REVERSE_PARAMETERS]*/
		delta = decodeLocalCount(b0, b1);
/*else[REVERSE_PARAMETERS]*/
//		delta = decodeLocalCount(b0, b1) + decodeStackCount(b0, b1);
/*end[REVERSE_PARAMETERS]*/
	} else {
		delta = getLocalCountPlusStackCountIfNotReversingParms(mp);
	}
	resetStackPointerFromDelta(delta);
}

/**
 * Clears the operand stack when REVERSE_PARAMETERS is true.
 */
/*MAC*/ void resetStackPointerIfRevParms() {
/*if[REVERSE_PARAMETERS]*/
	resetStackPointer();
/*end[REVERSE_PARAMETERS]*/
}

/**
 * Clears the operand stack when REVERSE_PARAMETERS is false.
 */
/*MAC*/ void resetStackPointerIfNotRevParms() {
/*if[REVERSE_PARAMETERS]*/
/*else[REVERSE_PARAMETERS]*/
//	resetStackPointer();
/*end[REVERSE_PARAMETERS]*/
}


/*-----------------------------------------------------------------------*\
 *                      Java String printing                             *
 \*-----------------------------------------------------------------------*/

/**
 * A macro defining whether or not the printJavaString function should
 * handle Strings with non-ascii characters.
 */
//#define UNICODE true

/**
 * Prints the contents of a Java String object to a given stream.
 * No trailing '\0' is printed/appended.
 *
 * @param str  the address of a Java String object
 * @param out  where to print the string's contents
 * @return the number of characters printed
 */
/*if[MICROBLAZE_BUILD]*/
int printJavaString(Address str) {
/*else[MICROBLAZE_BUILD]*/
//  int printJavaString(Address str, FILE* out) {
/*end[MICROBLAZE_BUILD]*/
#ifdef UNICODE
	int i;
#endif
	int written = 0;
	if (str == null) {
		written = fprintf(out, "null");
	} else {
		int length = getArrayLength(str);
#ifdef UNICODE
		Address cls = getClass(str);
		assume(((UWord)getObject(str, HDR_klass) & HDR_headerTagMask) == 0);
		if (com_sun_squawk_Klass_id(cls) == com_sun_squawk_StringOfBytes) {
#endif
			unsigned char *chars = (unsigned char *)str;
/*if[MICROBLAZE_BUILD]*/
			fprintf(out, "%s", chars);
/*else[MICROBLAZE_BUILD]*/
//			fprintf(out, "%.*s", length, chars);
/*end[MICROBLAZE_BUILD]*/
			written = length;
#ifdef UNICODE
		} else {
			unsigned short *chars = (unsigned short *)str;
			if (com_sun_squawk_Klass_id(cls) != com_sun_squawk_String) {
				fatalVMError("com_sun_squawk_VM_printString was not passed a string");
			}
			for (i = 0; i < length; i++) {
				fprintf(out, "%lc", chars[i]);
			}
			written = length;
		}
#endif
	}
	fflush(out);
	return written;
}

/**
 * Appends the contents of a Java String object
 * to a given buffer. No trailing '\0' is printed/appended.
 *
 * @param str  the address of a Java String object
 * @param buf  where to append the string's contents
 * @param bufLength the length of 'buf'
 * @return the number of characters appended
 */
int printJavaStringBuf(Address str, char *buf, int bufLength) {
#ifdef UNICODE
	int i;
#endif
	int written = 0;
	if (str == null) {
		int min = 4;
		if (min > bufLength) {
			min = bufLength;
		}
		memmove(buf, "null", min);
		written = min;
	} else {
		int length = getArrayLength(str);
#ifdef UNICODE
		Address cls = getClass(str);
		assume(((UWord)getObject(str, HDR_klass) & HDR_headerTagMask) == 0);
		if (com_sun_squawk_Klass_id(cls) == com_sun_squawk_StringOfBytes) {
#endif
			unsigned char *chars = (unsigned char *)str;
			int min = length;
			if (min > bufLength) {
				min = bufLength;
			}
			memmove(buf, chars, min);
			written = min;
#ifdef UNICODE
		} else {
			unsigned short *chars = (unsigned short *)str;
			if (com_sun_squawk_Klass_id(cls) != com_sun_squawk_String) {
				fatalVMError("com_sun_squawk_VM_printString was not passed a string");
			}
			for (i = 0; i < length && i < bufLength; i++) {
				buf[i] = (char)chars[i];
			}
			written = i;
		}
#endif
	}
	return written;
}


/*-----------------------------------------------------------------------*\
 *                                Upcalls                                *
\*-----------------------------------------------------------------------*/

/*if[CHECK_SLOT_CLEARING]*/
/**
 * Check that there are no 0xDEAFBEEF words in the local variables.
 */
/*MAC*/ void checkReferenceSlots() {
	if (fp_g != null) {
		int i;
		Address mp     = getMP();
		int nparms     = getParmCount(mp);
		int nlocals    = getLocalCount(mp);
		int vars       = nlocals + nparms;
		int oopmapLth  = (vars+7)/8;
		int oopMapOff  = getOffsetToLastMinfoByte(mp) - oopmapLth;
		int bitOffset  = (nparms - 1) % 8;
		int byteOffset = (nparms - 1) / 8;
		for (i = 0 ; i < nlocals ; i++) {
			int bite;
			boolean isOop;
			bitOffset++;
			if (bitOffset == 8) {
				bitOffset = 0;
				byteOffset++;
			}
			bite  = getByte(mp, oopMapOff + byteOffset);
			isOop = ((bite >> bitOffset) & 1) != 0;
			if (isOop) {
				UWord wd = peekLocal(i);
				if (wd == (UWord)0xDEAFBEEF) {
					fatalInterpreterError("0xDEAFBEEF found");
				}
			}
		}
	}
}
/*else[CHECK_SLOT_CLEARING]*/
//#define checkReferenceSlots()
/*end[CHECK_SLOT_CLEARING]*/

/**
 * Causes the Java method at 'mth' to be invoked without resetting the stack pointer.
 *
 * @param mth the address of the method to be invoked
 */
/*MAC*/ void callNoReset(Address $mth) {
	assumeInterp($mth != 0);
	assumeInterp(((UWord)getObject($mth, HDR_klass) & HDR_headerTagMask) == 0);
	assumeInterp(com_sun_squawk_Klass_id(getClass($mth)) == CID_BYTECODE_ARRAY);
	assumeInterp(inCode($mth));
	checkReferenceSlots();
	downPushAddress(ip_g);
	ip_g = $mth;
}

/**
 * Causes the Java method at 'mth' to be invoked, resetting the stack pointer first if necessary.
 *
 * @param mth the address of the method to be invoked
 */
/*MAC*/ void call(Address $mth) {
	resetStackPointerIfNotRevParms();
	callNoReset($mth);
}

/*
 * Call exception reporting method - and leave stack as if thrower called.
 * This call returns by rethrowing the original exception. VM.throwException notices the re-throw,
 * clears these magic flags, and sets up SC_lastFP (etc) to the catch block (see below).
 *
 * Using code fragment macro becuase of interaction of #ifdef and MACRO processing
 */
#if SDA_DEBUGGER
#define SDA_HANDLE_BREAKPOINT_CODE_FRAG	  \
	Address hbp;

if (!runningOnServiceThread_g &&                                                               \
    (hbp = com_sun_squawk_VMThread_hitBreakpoint(newThread)) != null &&                      \
    com_sun_squawk_HitBreakpoint_state(hbp) == com_sun_squawk_HitBreakpoint_EXC_HIT) {       \
	set_com_sun_squawk_HitBreakpoint_state(hbp, com_sun_squawk_HitBreakpoint_EXC_REPORTING); \
	/* fprintf(stderr, format("Calling do_reportException. newMP: %A, ipOffset: %O, ip: %A, fp: %A.\n", newMP, ipOffset, ip_g, fp_g); */ \
	call(com_sun_squawk_VM_reportException);                                                 \
} else {                                                                                     \
	/*fprintf(stderr, format("fp = %d newMP = %d ipoffset = %d ip=%d tid=%d returnFP=%A\n"), fp_g, newMP, ipOffset, ip_g, com_sun_squawk_VMThread_threadNumber(newThread), getObject(fp_g, FP_returnFP));*/ \
}
#else
#define SDA_HANDLE_BREAKPOINT_CODE_FRAG
#endif /*SDA_DEBUGGER */

/**
 * Switch to the 'other' thread.
 */
/*MAC*/ void threadswitchmain() {
	Address oldThread  = com_sun_squawk_VMThread_currentThread;
	Address oldStack   = (Address)com_sun_squawk_VMThread_stack(oldThread);
	UWord   oldMP      = (UWord)getObject(fp_g, FP_method);
	UWord   ipOffset   = ((UWord)ip_g) - oldMP;
	Address newThread  = com_sun_squawk_VMThread_otherThread;
	Address newStack   = (Address)com_sun_squawk_VMThread_stack(newThread);
	assumeInterp(newStack != null);
	assumeInterp(!com_sun_squawk_GC_collecting);

	/*fprintf(stderr, format("%%%%%%%%%%%%%% fp = %A oldMP = %A ipoffset = %d ip=%A tid=%d oldThread=%A oldStack=%A newThread=%A newStack=%A\n"), fp_g, oldMP, ipOffset, ip_g, com_sun_squawk_VMThread_threadNumber(oldThread), oldThread, oldStack, newThread, newStack);*/

	/*
	 * Save current VM state in the current thread.
	 */
	if (oldStack == null) {
		/* handle case from VMThread.abandonThread(). oldThread has died, and will not come back.*/
		assumeInterp(com_sun_squawk_VMThread_state(oldThread) == com_sun_squawk_VMThread_DEAD);
	} else {
		assumeInterp(oldStack == (Address)ss_g);
		setObject(oldStack, SC_lastFP, fp_g);
		setUWord(oldStack, SC_lastBCI, ipOffset);
	}

	/*
	 * Swap the threads and setup the current isolate.
	 */
	com_sun_squawk_VMThread_otherThread = oldThread;
	com_sun_squawk_VMThread_currentThread = newThread;
	if (TRACE)
		currentThreadID_g = com_sun_squawk_VMThread_threadNumber(newThread);

	/*
	 * If the new thread is not the service thread then switch the
	 * the current isolate to the new thread's isolate. This test means
	 * that code run on the service thread will run in the isolate
	 * context of the caller.
	 */
	if (newThread != com_sun_squawk_VMThread_serviceThread) {
		int oldRunningOnServiceThread = runningOnServiceThread_g;
		Address newIsolate = (Address)com_sun_squawk_VMThread_isolate(newThread);

		runningOnServiceThread_g = false;
		if (com_sun_squawk_VM_currentIsolate != newIsolate) {
			com_sun_squawk_VM_currentIsolate = newIsolate;
			invalidateClassStateCache();
			set_sda_bp_set_or_stepping(newIsolate); /* changed isolate */
		} else if (oldRunningOnServiceThread) {
			set_sda_bp_set_or_stepping(newIsolate); /* coming off of service thread */
		}

		/*
		 * If not simply switching back from the service thread to its caller
		 * then check that the number of pending monitor enter operations is zero.
		 */
		assumeInterp(oldThread == com_sun_squawk_VMThread_serviceThread
		             || pendingMonitorStackPointer_g == 0);

	} else {
		runningOnServiceThread_g = true;
		set_sda_bp_set_or_stepping(null); /* coming on to service thread */
	}

	if (TRACE) {
		if(runningOnServiceThread_g)
			printStackTracePrim(-1, ip_g, fp_g, "switched to service thread\n", null);
		else
			printStackTracePrim(-1, ip_g, fp_g, "switched back\n", null);
	}

	/*
	 * Switch to the new context.
	 */
	setStack(newStack);
	fp_g = getObject(ss_g, SC_lastFP);
	if (fp_g == null) {   /* New thread                   */
		fp_g = null;      /* The return FP should be zero */
		ip_g = null;    /* The return IP should be zero */
		sp_g = &ss_g[getArrayLength(ss_g)];
/*if[REVERSE_PARAMETERS]*/
		call(com_sun_squawk_VM_callRun);
/*else[REVERSE_PARAMETERS]*/
//		downPushAddress(ip_g);         /* don't call call() ... */
//		ip_g = com_sun_squawk_VM_callRun;   /* because resetStackPointer() will not work */
/*end[REVERSE_PARAMETERS]*/
		/*fprintf(stderr, "callRun: fp = %d sp=%d ip=%d tid = %d\n", fp_g, sp_g, ip_g, com_sun_squawk_VMThread_threadNumber(newThread));*/
	} else {

		assumeInterp(getMP() != null);
		ipOffset = getUWord(ss_g, SC_lastBCI);
		resetStackPointer();
		ip_g = (ByteAddress)getMP() + ipOffset;
		assumeInterp(inCode(ip_g));

		SDA_HANDLE_BREAKPOINT_CODE_FRAG
	}
}

/**
 * Switch to the 'other' thread.
 *
 * @param code the service operation code
 */
/*MAC*/ void threadSwitch(int $code) {
	/*
	 * Set the service operation code.
	 */
	com_sun_squawk_ServiceOperation_code = $code;
/*if[MACROIZE]*/
	goto threadswitchstart;
/*else[MACROIZE]*/
//	threadswitchmain();
/*end[MACROIZE]*/
}

/**
 * Switch to the service thread.
 */
/*MAC*/ void threadSwitchFor(int $code) {
	assumeInterp(!runningOnServiceThread_g);
	com_sun_squawk_VMThread_otherThread = com_sun_squawk_VMThread_serviceThread;
	threadSwitch($code);
}

/**
 * Execute a service operation for channel I/O.
 */
/*MAC*/ void executeCIO(int $context, int $op, int $channel, int $i1, int $i2, int $i3, int $i4, int $i5, int $i6, Address $o1, Address $o2) {
	com_sun_squawk_ServiceOperation_context = $context;
	com_sun_squawk_ServiceOperation_op      = $op;
	com_sun_squawk_ServiceOperation_channel = $channel;
	com_sun_squawk_ServiceOperation_i1      = $i1;
	com_sun_squawk_ServiceOperation_i2      = $i2;
	com_sun_squawk_ServiceOperation_i3      = $i3;
	com_sun_squawk_ServiceOperation_i4      = $i4;
	com_sun_squawk_ServiceOperation_i5      = $i5;
	com_sun_squawk_ServiceOperation_i6      = $i6;
	com_sun_squawk_ServiceOperation_o1      = $o1;
	com_sun_squawk_ServiceOperation_o2      = $o2;
	if (runningOnServiceThread_g) {
		void cioExecute(void);
		cioExecute();
	} else {
		threadSwitchFor(com_sun_squawk_ServiceOperation_CHANNELIO);
	}
}

/*-----------------------------------------------------------------------*\
 *                               Debugging                               *
 \*-----------------------------------------------------------------------*/

#if SDA_DEBUGGER
#define SDA_DEBUG_PRINT false

/*MAC*/ Address frameOffsetAsPointer(Address $stack, Offset $fpOffset) {
	return Address_sub(Address_add($stack, getArrayLength($stack) * HDR_BYTES_PER_WORD), $fpOffset);
}

/*MAC*/ Offset framePointerAsOffset(Address $stack, Address $fpPointer) {
	return Address_diff(Address_add($stack, getArrayLength($stack) * HDR_BYTES_PER_WORD), $fpPointer);
}

/*MAC*/ void sda_checkStepPrim(ByteAddress $actual_ip, UWordAddress $actual_fp, UWordAddress $actual_sp) {
	Address thread = com_sun_squawk_VMThread_currentThread;
	Address step = com_sun_squawk_VMThread_step(thread);
	Offset currentFO = framePointerAsOffset(ss_g, $actual_fp);
	Address startFP = frameOffsetAsPointer(ss_g, com_sun_squawk_Debugger_SingleStep_startFO(step));
	int state = com_sun_squawk_Debugger_SingleStep_state(step);

	if (!inSystemFrame(startFP, (Address)$actual_fp)) {
		switch (state) {
		case com_sun_squawk_Debugger_SingleStep_DEFERRED: {
			/* A couple of optimizations for determining when we should go from DEFERRED to REQUESTED.
			 *
			 * 1) The last 'hit' was cancelled because it was in a class excluded by step request (via a ClassExclude modifier).
			 * Each successive hit will fail until the current frame changes.
			 *
			 * Once the current frame changes, the state is reset to REQUESTED.
			 *
			 * 2) If the class of the method where the step was cancelled is the same as the
			 * current method's class, break.
			 */

			Offset reportedFO = com_sun_squawk_Debugger_SingleStep_reportedFO(step);
			if (currentFO == reportedFO) {
				/* Still in a method of an excluded class */
				break;
			} else if (currentFO < reportedFO) {
				Address reportedFP = frameOffsetAsPointer(ss_g, reportedFO);
				Address reportedMP = getObject(reportedFP, FP_method);
				Address currentMP = getObject($actual_fp, FP_method);
				assumeInterp(((UWord)getObject(reportedMP, HDR_klass) & HDR_headerTagMask) == 0);
				assumeInterp(((UWord)getObject(currentMP, HDR_klass) & HDR_headerTagMask) == 0);
				{
					Address classOfReportedMP = getClass(reportedMP);
					Address classOfCurrentMP = getClass(currentMP);

					if (classOfReportedMP == classOfCurrentMP) {
						break;
					}
				}
			}

			set_com_sun_squawk_Debugger_SingleStep_state(step, com_sun_squawk_Debugger_SingleStep_REQUESTED);
			set_com_sun_squawk_Debugger_SingleStep_reportedFO(step, (Offset) 0);
			set_com_sun_squawk_Debugger_SingleStep_reportedBCI(step, (Offset) 0);
			/* intentionally falls through to case com_sun_squawk_Debugger_SingleStep_REQUESTED */
		}
		case com_sun_squawk_Debugger_SingleStep_REQUESTED: {
			Address mp = getObject($actual_fp, FP_method);
			boolean stepped = sda_handleSingleStep($actual_ip, $actual_fp, $actual_sp, mp, step);
			/* Report the step event */
			if (stepped) {
				Offset currentBCI = Address_diff($actual_ip, mp);
				/*fprintf(stderr, format("Signaling STEP event hit @ currentFO: %A, currentBCI: %A\n"), currentFO, currentBCI);*/
				/* We set the state here - otherwise the this method will check for step events when the handler is running */
				set_com_sun_squawk_Debugger_SingleStep_state(step, com_sun_squawk_Debugger_SingleStep_HIT);
				set_com_sun_squawk_Debugger_SingleStep_reportedFO(step, currentFO);
				set_com_sun_squawk_Debugger_SingleStep_reportedBCI(step, currentBCI);

				pushWord(currentFO);
				pushWord(currentBCI);
				callNoReset(com_sun_squawk_VM_reportStepEvent);
			}
			break;
		}
		default: {
			fatalInterpreterError("sda_checkStep(): Should not reach here\n");
		}
		}
	}
}

/**
 * Checks for stepping events.
 */
/*MAC*/ void sda_checkStep(ByteAddress $actual_ip, UWordAddress $actual_fp, UWordAddress $actual_sp) {
	Address thread = com_sun_squawk_VMThread_currentThread;
	Address step = com_sun_squawk_VMThread_step(thread);
	int state;

	/* We proceed if:
	 *      1) step is not null and state is not STATE_HIT
	 *      2) operand stack is empty
	 *      3) opcode != EXTEND, EXTEND0, EXTEND_WIDE, CLASS_CLINIT, BBTARGET_APP, BBTARGET_SYS
	 */
	if (step != null && (state = com_sun_squawk_Debugger_SingleStep_state(step)) != com_sun_squawk_Debugger_SingleStep_HIT &&
	    sda_isOperandStackEmpty($actual_fp, $actual_sp))
	{
		int thisOpcode = getUByteTyped($actual_ip, 0, AddressType_BYTECODE);
		switch (thisOpcode) {
		case OPC_EXTEND:
		case OPC_EXTEND0:
		case OPC_EXTEND_WIDE:
		case OPC_CLASS_CLINIT:
		case OPC_BBTARGET_APP:
		case OPC_BBTARGET_SYS: break;
		default:
			sda_checkStepPrim($actual_ip, $actual_fp, $actual_sp);
			break;
		}
	}
}
/**
 * Handles the logic for determining if a step event has occurred when the frames are different.
 * We want to know if the startFO is still on the stack - this tells us that we are in a frame
 * that the startFO has called.
 *
 * If we are in STEP_OVER or STEP_OUT, we don't want this to cause an event, so we return false, otherwise we don't.
 * If we are in STEP_IN, the above test doesn't apply so we return true.
 */
boolean sda_handleSingleStepWhenFrameIsDifferent(UWordAddress actual_fp, Offset startFO, int depth) {
	boolean sendEvent = true;

	if (depth == com_sun_squawk_debugger_JDWP_StepDepth_OVER || depth == com_sun_squawk_debugger_JDWP_StepDepth_OUT) {
		UWordAddress prevFP = (UWordAddress)getObject(actual_fp, FP_returnFP);
		assume(prevFP > actual_fp);
		while (prevFP != null) {
			if (framePointerAsOffset(ss_g, prevFP) == startFO) {
#if SDA_DEBUG_PRINT
				fprintf(stderr, format("sda_handleSingleStep(): Found the frame where stepping was initiated\n"));
#endif
				sendEvent = false;
				break;
			}
			prevFP = (UWordAddress)getObject(prevFP, FP_returnFP);
		}
	}
	return sendEvent;
}

/**
 * Determines whether or not a requested step event has been completed and should be reported to
 * the attached debugger.
 */
boolean sda_handleSingleStep(ByteAddress actual_ip, UWordAddress actual_fp, UWordAddress actual_sp, Address mp, Address step) {
	Offset currentFO = framePointerAsOffset(ss_g, actual_fp);
	Offset startFO = com_sun_squawk_Debugger_SingleStep_startFO(step);
	int targetBCI = com_sun_squawk_Debugger_SingleStep_targetBCI(step);
	int size = com_sun_squawk_Debugger_SingleStep_size(step);
	int depth = com_sun_squawk_Debugger_SingleStep_depth(step);

	/* Squawk does -not- support com_sun_squawk_debugger_JDWP_StepSize_MIN */
	assume(size == com_sun_squawk_debugger_JDWP_StepSize_LINE);
	/* We're assuming that the current method pointer is not one invoked by the interpreter */
	assume(!isInterpreterInvoked(mp));

#if SDA_DEBUG_PRINT
	fprintf(stderr, format("sda_handleSingleStep(): targetBCI: %d, currentFO: %O, startFO: %O, size: %d, depth: %d\n"), targetBCI, currentFO, startFO, size, depth);
#endif

	if (targetBCI == -1) {
		/* Wait for the frame to change and that will mean we popped up to
		 * the calling frame. (Or we called down to another frame, maybe...
		 * should look into that possibility)
		 */
		boolean sendEvent = false;
		if (currentFO != startFO) {
			sendEvent = sda_handleSingleStepWhenFrameIsDifferent(actual_fp, startFO, depth);
		}
#if SDA_DEBUG_PRINT
		if (sendEvent) {
			fprintf(stderr, format("sda_handleSingleStep(): targetBCI == -1 and step event occurred\n"));
		}
#endif
		return sendEvent;
	} else {
		Offset currentBCI = Address_diff(actual_ip, mp);
		if (currentFO == startFO) {
			Offset startBCI = com_sun_squawk_Debugger_SingleStep_startBCI(step);
			int dupBCI = com_sun_squawk_Debugger_SingleStep_dupBCI(step);
			int afterDupBCI = com_sun_squawk_Debugger_SingleStep_afterDupBCI(step);
#if SDA_DEBUG_PRINT
			dumpSteppingInfo(currentBCI, currentFO, step);
#endif
			/* if the frame is the same and we are not running to the
			 * end of a function we need to see if we have reached
			 * the location we are looking for
			 */
			if (depth != com_sun_squawk_debugger_JDWP_StepDepth_OUT) {
				if (currentBCI == targetBCI) {
#if SDA_DEBUG_PRINT
					fprintf(stderr, format("handleSingleStep() - CASE 1: we are at the target offset\n"));
#endif
					/* At the target offset */
					return true;
				} else if (currentBCI < startBCI && (dupBCI == -1 || afterDupBCI == -1)) {
#if SDA_DEBUG_PRINT
					fprintf(stderr, format("handleSingleStep() - CASE 2: we are before the start offset \n"));
#endif
					/* Reached an offset before the offset where stepping was initiated - there's also
					 * no duplicate information
					 */
					return true;
				} else if (currentBCI > targetBCI && currentBCI > startBCI) {
					/* Past the target offset and the offset where stepping was initiated */
					if (dupBCI == -1 || afterDupBCI == -1) {
#if SDA_DEBUG_PRINT
						fprintf(stderr, format("handleSingleStep() - CASE 3: we are after the target and start offsets and there is no duplicate offset\n"));
#endif
						/* there's no duplicate information (like there would be in a for/while loop)
						 * Sometimes caused by a break in a switch/case.  We checked if the starting
						 * offset is equal to our current - if so don't issue an event otherwise we'll
						 * be in an infinite loop.
						 */
						return true;
					} else if (currentBCI >= dupBCI && currentBCI >= afterDupBCI) {
#if SDA_DEBUG_PRINT
						fprintf(stderr, format("handleSingleStep() - CASE 4: we are after the target and start offsets and either at or past the duplicate offset\n"));
#endif
						/* we are at or beyond the end of a for/while loop (doing the loop test). */
						return true;
					}
				}
			}
		} else {
			/* the frame has changed but we don't know whether we have gone into a function or gone up one.
			 * if we look up the call stack and find the frame that originally set the request then we stepped
			 * into a function, otherwise we stepped out
			 */
			boolean sendEvent = sda_handleSingleStepWhenFrameIsDifferent(actual_fp, startFO, depth);

#if SDA_DEBUG_PRINT
			dumpSteppingInfo(currentBCI, currentFO, step);
			if (sendEvent) {
				fprintf(stderr, format("sda_handleSingleStep(): frame has changed, causing a step event\n"));
			}
#endif
			return sendEvent;
		}
	}
	return false;
}

/**
 * Determines if the interpreter is at a breakpoint or end of a step and calls
 * into the appropriate Java routine if it is.
 */
/*MAC*/ void sda_checkBreakOrStep(ByteAddress $actual_ip, UWordAddress $actual_fp, UWordAddress $actual_sp) {
	if (unlikely(sda_bp_set_or_stepping)) {
		Address thread = com_sun_squawk_VMThread_currentThread;
		Address hbp = com_sun_squawk_VMThread_hitBreakpoint(thread);
		if (hbp == null) {
			boolean atBreakpoint = false;
			ByteAddress bp_ip;
			if (sda_breakpoints[0] != NULL) {
				int i = 0;
				while ((bp_ip = sda_breakpoints[i++]) != null) {
					if (bp_ip == $actual_ip) {
						/*
						 * Call breakpoint reporting method - and leave stack as if current method called.
						 * com_sun_squawk_VM_reportBreakpoint().
						 */
						Address mp      = getObject($actual_fp, FP_method);
						Offset currentBCI = Address_diff($actual_ip, mp);
						Offset currentFO = framePointerAsOffset(ss_g, $actual_fp);
						/*fprintf(stderr, format("Hit breakpoint #%d: in method: %A, currentBCI: %O ip: %A currentFO: %O fp: %A\n"),  i, mp, currentBCI, $actual_ip, currentFO, $actual_fp);*/

						if (!sda_isOperandStackEmpty($actual_fp, $actual_sp)) {
							fatalInterpreterError("Tried to report a breakpoint when operand stack was not empty.\n");
						}

						pushWord(currentFO);
						pushWord(currentBCI);
						call(com_sun_squawk_VM_reportBreakpoint);
						atBreakpoint = true;
						break;
					}
				}
			}
			if (!atBreakpoint) {
				sda_checkStep($actual_ip, $actual_fp, $actual_sp);
			}
		} else if (com_sun_squawk_HitBreakpoint_state(hbp) == com_sun_squawk_HitBreakpoint_BP_REPORTED) {
			/*
			 * In the middle of reporting the breakpoint. If the current frame and BCI
			 * is equal to the thread's saved frame and BCI, then we are done reporting the
			 * breakpoint, and we clean up reporting, and execute the next instruction normally.
			 */
			if (framePointerAsOffset(ss_g, $actual_fp) == com_sun_squawk_HitBreakpoint_hitOrThrowFO(hbp)) {
				Address mp      = getObject($actual_fp, FP_method);
				Offset currentBCI = Address_diff($actual_ip, mp);
				if (currentBCI == com_sun_squawk_HitBreakpoint_hitOrThrowBCI(hbp)) {
					set_com_sun_squawk_VMThread_hitBreakpoint(thread, null);
					/*fprintf(stderr, format("Done reporting breakpoint in method: %A, offset: %O\n"), mp, currentBCI);*/
				}
			}
		}
	}
}
#endif /* SDA_DEBUGGER */

/*-----------------------------------------------------------------------*\
 *                               Constants                               *
 \*-----------------------------------------------------------------------*/

/**
 * Pushes a constant value.
 *
 * <p>
 * Java Stack: ... -> ..., INT
 * <p>
 *
 * @param n the integer value
 */
/*MAC*/ void do_const_n(Offset $n) {
	pushInt($n);
}

/**
 * Pushes a constant null value.
 *
 * <p>
 * Java Stack: ... -> ..., INT
 * <p>
 *
 * @param n the integer value
 */
/*MAC*/ void do_const_null() {
	pushAddress(0);
}

/**
 * Pushes a constant byte value.
 *
 * <p>
 * Java Stack: ... -> ..., INT
 * <p>
 */
/*MAC*/ void do_const_byte() {
	pushInt(fetchByte());
}

/**
 * Pushes a constant short value.
 *
 * <p>
 * Java Stack: ... -> ..., INT
 * <p>
 */
/*MAC*/ void do_const_short() {
	int fparm;
	fetchShort();
	pushInt(fparm);
}

/**
 * Pushes a constant char value.
 *
 * <p>
 * Java Stack: ... -> ..., INT
 * <p>
 */
/*MAC*/ void do_const_char() {
	int fparm;
	fetchUShort();
	pushInt(fparm);
}

/**
 * Pushes a constant int value.
 *
 * <p>
 * Java Stack: ... -> ..., INT
 * <p>
 */
/*MAC*/ void do_const_int() {
	int fparm;
	fetchInt();
	pushInt(fparm);
}

/**
 * Pushes a constant long value.
 *
 * <p>
 * Java Stack: ... -> ..., LONG
 * <p>
 */
/*MAC*/ void do_const_long() {
	jlong flparm;
	fetchLong();
	pushLong(flparm);
}

/**
 * Pushes a constant floa value.
 *
 * <p>
 * Java Stack: ... -> ..., FLOAT
 * <p>
 */
/*MAC*/ void do_const_float() {
	int fparm;
	fetchInt();
	pushInt(fparm);
}

/**
 * Pushes a constant double value.
 *
 * <p>
 * Java Stack: ... -> ..., DOUBLE
 * <p>
 */
/*MAC*/ void do_const_double() {
	jlong flparm;
	fetchLong();
	pushLong(flparm);
}

/**
 * Pushes a constant object value.
 *
 * <p>
 * Java Stack: ... -> ..., OOP
 * <p>
 *
 * @param n the index into the class object table
 */
/*MAC*/ void do_object_n(int $n) {
	pushAddress(getKlassObject($n));
}

/**
 * Pushes a constant object value.
 *
 * <p>
 * Java Stack: ... -> ..., OOP
 * <p>
 */
/*MAC*/ void do_object() {
	do_object_n(iparm_g);
}


/*-----------------------------------------------------------------------*\
 *                          Access to locals                             *
 \*-----------------------------------------------------------------------*/

/**
 * Pushes a single word local.
 *
 * <p>
 * Java Stack: ... -> ..., VALUE
 * <p>
 *
 * @param n the index to local
 */
/*MAC*/ void do_load_n(int $n) {
	pushAsType(getLocal($n), getMutationType());
}

/**
 * Pushes a single word local.
 *
 * <p>
 * Java Stack: ... -> ..., VALUE
 * <p>
 */
/*MAC*/ void do_load() {
	do_load_n(iparm_g);
}

/**
 * Pops a single word local.
 *
 * <p>
 * Java Stack: ..., VALUE -> ...
 * <p>
 *
 * @param n the index to local
 */
/*MAC*/ void do_store_n(int $n) {
	setLocal($n, popAsType(getMutationType()));
}

/**
 * Pops a single word local.
 *
 * <p>
 * Java Stack: ..., VALUE -> ...
 * <p>
 */
/*MAC*/ void do_store() {
	do_store_n(iparm_g);
}

/**
 * Pushes a double word local.
 *
 * <p>
 * Java Stack: ... -> ..., LONG
 * <p>
 */
/*MAC*/ void do_load_i2() {
	if (TYPEMAP & SQUAWK_64) {
		if (getMutationType() == AddressType_REF) {
			pushAsType(getLocal(iparm_g), AddressType_REF);
		} else if (getMutationType() == AddressType_UWORD) {
			pushAsType(getLocal(iparm_g), AddressType_UWORD);
		} else {
			pushLong(getLocalLong(iparm_g));
		}
	} else {
		pushLong(getLocalLong(iparm_g));
	}
}

/**
 * Pops a double word local.
 *
 * <p>
 * Java Stack: ..., LONG -> ...
 * <p>
 */
/*MAC*/ void do_store_i2() {
	if (TYPEMAP & SQUAWK_64) {
		if (getMutationType() == AddressType_REF) {
			setLocal(iparm_g, popAsType(AddressType_REF));
		} else if (getMutationType() == AddressType_UWORD) {
			setLocal(iparm_g, popAsType(AddressType_UWORD));
		} else {
			setLocalLong(iparm_g, popLong());
		}
	} else {
		setLocalLong(iparm_g, popLong());
	}
}

/**
 * Increment a single word local.
 *
 * <p>
 * Java Stack: ... -> ...
 * <p>
 */
/*MAC*/ void do_inc() {
	setLocal(iparm_g, getLocal(iparm_g) + 1);
}

/**
 * Decrement a single word local.
 *
 * <p>
 * Java Stack: ... -> ...
 * <p>
 */
/*MAC*/ void do_dec() {
	setLocal(iparm_g, getLocal(iparm_g) - 1);
}


/*-----------------------------------------------------------------------*\
 *                         Access to parameters                          *
 \*-----------------------------------------------------------------------*/

/**
 * Pushes a single word parm.
 *
 * <p>
 * Java Stack: ... -> ..., VALUE
 * <p>
 *
 * @param n the index to local
 */
/*MAC*/ void do_loadparm_n(int $n) {
	pushAsType(getParm($n), getMutationType());
}

/**
 * Pushes a single word parm.
 *
 * <p>
 * Java Stack: ... -> ..., VALUE
 * <p>
 */
/*MAC*/ void do_loadparm() {
	do_loadparm_n(iparm_g);
}

/**
 * Pops a single word parm.
 *
 * <p>
 * Java Stack: ..., VALUE -> ...
 * <p>
 */
/*MAC*/ void do_storeparm_n(int $n) {
	setParm($n, popAsType(getMutationType()));
}

/**
 * Pops a single word parm.
 *
 * <p>
 * Java Stack: ..., VALUE -> ...
 * <p>
 */
/*MAC*/ void do_storeparm() {
	do_storeparm_n(iparm_g);
}

/**
 * Pushes a double word parm.
 *
 * <p>
 * Java Stack: ... -> ..., LONG
 * <p>
 */
/*MAC*/ void do_loadparm_i2() {
	if (TYPEMAP & SQUAWK_64) {
		if (getMutationType() == AddressType_REF) {
			pushAsType(getParm(iparm_g), AddressType_REF);
		} else if (getMutationType() == AddressType_UWORD) {
			pushAsType(getParm(iparm_g), AddressType_UWORD);
		} else {
			pushLong(getParmLong(iparm_g));
		}
	} else {
		pushLong(getParmLong(iparm_g));
	}
}

/**
 * Pops a double word parm.
 *
 * <p>
 * Java Stack: ..., VALUE -> ...
 * <p>
 *
 */
/*MAC*/ void do_storeparm_i2() {
	if (TYPEMAP & SQUAWK_64) {
		if (getMutationType() == AddressType_REF) {
			setParm(iparm_g, popAsType(AddressType_REF));
		} else if (getMutationType() == AddressType_UWORD) {
			setParm(iparm_g, popAsType(AddressType_UWORD));
		} else {
			setParmLong(iparm_g, popLong());
		}
	} else {
		setParmLong(iparm_g, popLong());
	}
}

/**
 * Increment a single word parm.
 *
 * <p>
 * Java Stack: ... -> ...
 * <p>
 */
/*MAC*/ void do_incparm() {
	setParm(iparm_g, getParm(iparm_g) + 1);
}

/**
 * Decrement a single word parm.
 *
 * <p>
 * Java Stack: ... -> ...
 * <p>
 */
/*MAC*/ void do_decparm() {
	setParm(iparm_g, getParm(iparm_g) - 1);
}


/*-----------------------------------------------------------------------*\
 *                               Branching                               *
 \*-----------------------------------------------------------------------*/

/**
 * Modifies the global 'tracing' flag if a user specified backward branch threshold
 * has been met. This function also stops the VM if another user specified
 * threshold has been met.
 */
/*INL*/ void bbtarget_trace() {
#if TRACE
	jlong count;
	int low = (int)((branchCountLow_g + 1) & 0xFFFFFFFF);
	branchCountLow_g = low;
	if (low == 0) {
		UWord high = branchCountHigh_g + 1;
		branchCountHigh_g = high;
	}
	count = getBranchCount();
/*if[!MICROBLAZE_BUILD]*/
	if (statsFrequency != 0 && (count % statsFrequency) == 0) {
		printCacheStats();
	}
/*end[MICROBLAZE_BUILD]*/
	if (count >= getTraceStart()) {
		com_sun_squawk_VM_tracing = true;
	}
	if (count >= getTraceEnd()) {
		fprintf(stderr, format("\n** Reached branch count limit %L **\n"), getBranchCount());
		stopVM(-1);
	}
#endif
}


/**
 * Backward branch target in system code.
 *
 * <p>
 * Java Stack:  _  ->  _
 * <p>
 */
/*MAC*/ void do_bbtarget_sys() {
	osbackbranch();
/*if[!MICROBLAZE_BUILD]*/
	bbtarget_trace();
/*end[MICROBLAZE_BUILD]*/
	checkReferenceSlots();
}

/**
 * Backward branch target in application code.
 *
 * <p>
 * Java Stack:  _  ->  _
 * <p>
 */
/*MAC*/ void do_bbtarget_app() {
	do_bbtarget_sys();
	if (unlikely(bc_g++ >= 0)) {
		bc_g = -TIMEQUANTA;
		call(com_sun_squawk_VM_yield);
	}
}

#ifdef FLASH_MEMORY
/**
 * Force back branch count to zero so that reschedule will occur.
 * NB. This function is forced into a special section so that it can be put in RAM.
 */
__attribute__ ((section (".textinram"))) void force_bb_expired() {
	bc_g = 0;
}
#endif

/**
 * Unconditional branch.
 *
 * <p>
 * Java Stack: ... -> ...  (Forward branches);
 * <p>
 * Java Stack:  _  ->  _   (Backward branches);
 * <p>
 */
/*MAC*/ void do_goto() {
	ip_g += iparm_g;
}

/**
 * Gets the right hand operand for the comparison in an 'if...' instruction.
 *
 * @param zero  specifies if the right hand operand is 0 or is on the stack
 */
/*DEF*/ Address rhs_o(boolean $zero) { return $zero ? 0 : popAddress(); }
/*DEF*/ int     rhs_i(boolean $zero) { return $zero ? 0 : popInt();     }
/*DEF*/ jlong   rhs_l(boolean $zero) { return $zero ? 0 : popLong();    }

/**
 * Conditional branch based on a comparison between object values.
 *
 * <p>
 * Java Stack: ..., LEFT_VALUE, [RIGHT_VALUE] -> ...  (Forward branches);
 * <p>
 * Java Stack:      LEFT_VALUE, [RIGHT_VALUE] ->  _   (Backward branches);
 * <p>
 *
 * @param zero  if true, then RIGHT_VALUE is given the value 0 (and thus not popped from the stack)
 */
/*MAC*/ void do_if_eq_o(boolean $zero) { Address rhs = rhs_o($zero); if (popAddress() == rhs) do_goto(); }
/*MAC*/ void do_if_ne_o(boolean $zero) { Address rhs = rhs_o($zero); if (popAddress() != rhs) do_goto(); }

/**
 * Conditional branch based on a comparison between int values.
 *
 * <p>
 * Java Stack: ..., LEFT_VALUE, [RIGHT_VALUE] -> ...  (Forward branches);
 * <p>
 * Java Stack:      LEFT_VALUE, [RIGHT_VALUE] ->  _   (Backward branches);
 * <p>
 *
 * @param zero  if true, then RIGHT_VALUE is given the value 0 (and thus not popped from the stack)
 */
/*MAC*/ void do_if_eq_i(boolean $zero) { int rhs = rhs_i($zero); if (popInt() == rhs) do_goto(); }
/*MAC*/ void do_if_ne_i(boolean $zero) { int rhs = rhs_i($zero); if (popInt() != rhs) do_goto(); }
/*MAC*/ void do_if_lt_i(boolean $zero) { int rhs = rhs_i($zero); if (popInt() <  rhs) do_goto(); }
/*MAC*/ void do_if_le_i(boolean $zero) { int rhs = rhs_i($zero); if (popInt() <= rhs) do_goto(); }
/*MAC*/ void do_if_gt_i(boolean $zero) { int rhs = rhs_i($zero); if (popInt() >  rhs) do_goto(); }
/*MAC*/ void do_if_ge_i(boolean $zero) { int rhs = rhs_i($zero); if (popInt() >= rhs) do_goto(); }

/**
 * Conditional branch based on a comparison between long values.
 *
 * <p>
 * Java Stack: ..., LEFT_VALUE, [RIGHT_VALUE] -> ...  (Forward branches);
 * <p>
 * Java Stack:      LEFT_VALUE, [RIGHT_VALUE] ->  _   (Backward branches);
 * <p>
 *
 * @param zero  if true, then RIGHT_VALUE is given the value 0 (and thus not popped from the stack)
 */
/*MAC*/ void do_if_eq_l(boolean $zero) { jlong rhs = rhs_l($zero); if (popLong() == rhs) do_goto(); }
/*MAC*/ void do_if_ne_l(boolean $zero) { jlong rhs = rhs_l($zero); if (popLong() != rhs) do_goto(); }
/*MAC*/ void do_if_lt_l(boolean $zero) { jlong rhs = rhs_l($zero); if (popLong() <  rhs) do_goto(); }
/*MAC*/ void do_if_le_l(boolean $zero) { jlong rhs = rhs_l($zero); if (popLong() <= rhs) do_goto(); }
/*MAC*/ void do_if_gt_l(boolean $zero) { jlong rhs = rhs_l($zero); if (popLong() >  rhs) do_goto(); }
/*MAC*/ void do_if_ge_l(boolean $zero) { jlong rhs = rhs_l($zero); if (popLong() >= rhs) do_goto(); }

/**
 * Gets a table switch parameter.
 */
/*DEF*/ void getSwitchEntry(int $size) {
	if ($size == 2) {
		fetchShort();
	} else {
		fetchInt();
	}
}

/**
 * General table switch.
 *
 * <p>
 * Java Stack: KEY ->  _
 * <p>
 *
 * @param  size  the size (in bytes) of an entry in the jump table
 */
/*MAC*/ void do_tableswitch(int $size) {
	int fparm;
	int key;
	int low;
	int high;

	/*
	  @TODO: FIX to not use mod (%). Very slow on ARM.
	*/
	/*
	 * Skip the padding.
	 */
	while ((((UWord)ip_g) % $size) != 0) {
		(void)fetchByte();
	}

	/*
	 * Read the low and high bound and the default case.
	 */
	getSwitchEntry($size);
	low   = fparm;
	getSwitchEntry($size);
	high  = fparm;
	getSwitchEntry($size);
	iparm_g = fparm;

	/*
	 * Get the key.
	 */
	key = popInt();

	/*
	 * Calculate the new IP.
	 */
	if (key >= low && key <= high) {
		if ($size == 4) {
			iparm_g = getIntTyped(ip_g, key-low, AddressType_ANY);
		} else {
			iparm_g = getShortTyped(ip_g, key-low, AddressType_ANY);
		}
	}

	/*
	 * Update the IP.
	 */
	do_goto();
}


/*-----------------------------------------------------------------------*\
 *                          Static field loads                           *
 \*-----------------------------------------------------------------------*/

/**
 * Gets the class that a putstatic or getstatic instruction operates on.
 *
 * @param inCP    specifies if the class whose field to be accessed is
 *                the current class or is on the stack
 * @return the class whose static field is being accessed
 */
/*DEF*/ Address getStaticFieldClass(boolean $inCP) {
	return $inCP ? getCP() : popAddress();
}

/**
 * Loads a value from a static int field.
 *
 * <p>
 * Java Stack: CLASS -> VALUE
 * <p>
 *
 * @param inCP    specifies if the class whose field to be accessed is
 *                the current class or is on the stack
 */
/*MAC*/ void do_getstatic_i(boolean $inCP) {
	Address klass = getStaticFieldClass($inCP);
	Address state = VM_getClassStateREAL(klass);
	if (state != null) {
		checkReferenceSlots();
		boundsAssume(state, iparm_g);
		pushInt(getUWord(state, iparm_g));
	} else {
		pushAddress(klass);
		pushInt(iparm_g);
		call(com_sun_squawk_VM_getStaticInt);
	}
}

/**
 * Loads a value from a static long field.
 *
 * <p>
 * Java Stack: CLASS -> VALUE
 * <p>
 *
 * @param inCP    specifies if the class whose field to be accessed is
 *                the current class or is on the stack
 */
/*MAC*/ void do_getstatic_l(boolean $inCP) {
	Address klass = getStaticFieldClass($inCP);
	Address state = VM_getClassStateREAL(klass);
	if (state != null) {
		checkReferenceSlots();
		boundsAssume(state, iparm_g);
		pushLong(getLongAtWord(state, iparm_g));
	} else {
		pushAddress(klass);
		pushInt(iparm_g);
		call(com_sun_squawk_VM_getStaticLong);
	}
}

/**
 * Loads a value from a static object field.
 *
 * <p>
 * Java Stack: CLASS -> VALUE
 * <p>
 *
 * @param inCP    specifies if the class whose field to be accessed is
 *                the current class or is on the stack
 */
/*MAC*/ void do_getstatic_o(boolean $inCP) {
	Address klass = getStaticFieldClass($inCP);
	Address state = VM_getClassStateREAL(klass);
	if (state != null) {
		checkReferenceSlots();
		boundsAssume(state, iparm_g);
		pushAddress(getObject(state, iparm_g));
	} else {
		pushAddress(klass);
		pushInt(iparm_g);
		call(com_sun_squawk_VM_getStaticOop);
	}
}

/*if[FLOATS]*/
/**
 * Loads a value from a static float field.
 *
 * <p>
 * Java Stack: CLASS -> VALUE
 * <p>
 *
 * @param inCP    specifies if the class whose field to be accessed is
 *                the current class or is on the stack
 */
/*MAC*/ void do_getstatic_f(boolean $inCP) {
	do_getstatic_i($inCP);
}

/**
 * Loads a value from a static double field.
 *
 * <p>
 * Java Stack: CLASS -> VALUE
 * <p>
 *
 * @param inCP    specifies if the class whose field to be accessed is
 *                the current class or is on the stack
 */
/*MAC*/ void do_getstatic_d(boolean $inCP) {
	do_getstatic_l($inCP);
}
/*end[FLOATS]*/

/*-----------------------------------------------------------------------*\
 *                          Static field stores                          *
 \*-----------------------------------------------------------------------*/

/**
 * Stores a value to a static int field.
 *
 * <p>
 * Java Stack: VALUE, CLASS -> _
 * <p>
 *
 * @param inCP    specifies if the class whose field to be accessed is
 *                the current class or is on the stack
 */
/*MAC*/ void do_putstatic_i(boolean $inCP) {
	Address klass = getStaticFieldClass($inCP);
	Address state = VM_getClassStateREAL(klass);
	if (state != null) {
		checkReferenceSlots();
		boundsAssume(state, iparm_g);
		setUWord(state, iparm_g, popInt());
	} else {
		pushAddress(klass);
		pushInt(iparm_g);
		call(com_sun_squawk_VM_putStaticInt);
	}
}

/**
 * Stores a value to a static long field.
 *
 * <p>
 * Java Stack: VALUE, CLASS -> _
 * <p>
 *
 * @param inCP    specifies if the class whose field to be accessed is
 *                the current class or is on the stack
 */
/*MAC*/ void do_putstatic_l(boolean $inCP) {
	Address klass = getStaticFieldClass($inCP);
	Address state = VM_getClassStateREAL(klass);
	if (state != null) {
		checkReferenceSlots();
		boundsAssume(state, iparm_g);
		setLongAtWord(state, iparm_g, popLong());
	} else {
		pushAddress(klass);
		pushInt(iparm_g);
		call(com_sun_squawk_VM_putStaticLong);
	}
}

/**
 * Stores a value to a static object field.
 *
 * <p>
 * Java Stack: VALUE, CLASS -> _
 * <p>
 *
 * @param inCP    specifies if the class whose field to be accessed is
 *                the current class or is on the stack
 */
/*MAC*/ void do_putstatic_o(boolean $inCP) {
	Address klass = getStaticFieldClass($inCP);
	Address state = VM_getClassStateREAL(klass);
	if (state != null) {
		checkReferenceSlots();
		boundsAssume(state, iparm_g);
		setObjectAndUpdateWriteBarrier(state, iparm_g, popAddress());
	} else {
		pushAddress(klass);
		pushInt(iparm_g);
		call(com_sun_squawk_VM_putStaticOop);
	}
}

/*if[FLOATS]*/
/**
 * Stores a value to a static float field.
 *
 * <p>
 * Java Stack: VALUE, CLASS -> _
 * <p>
 *
 * @param inCP    specifies if the class whose field to be accessed is
 *                the current class or is on the stack
 */
/*MAC*/ void do_putstatic_f(boolean $inCP) {
	do_putstatic_i($inCP);
}

/**
 * Stores a value to a static double field.
 *
 * <p>
 * Java Stack: VALUE, CLASS -> _
 * <p>
 *
 * @param inCP    specifies if the class whose field to be accessed is
 *                the current class or is on the stack
 */
/*MAC*/ void do_putstatic_d(boolean $inCP) {
	do_putstatic_l($inCP);
}
/*end[FLOATS]*/

/*-----------------------------------------------------------------------*\
 *                         Instance field access                         *
 \*-----------------------------------------------------------------------*/

/**
 * Check for a null pointer.
 *
 * @param oop the pointer
 * @param checkSlots true if slot checking should be performed
 */
/*DEF*/ void nullCheckPrim(Address $oop, boolean $checkSlots) {
	if ($checkSlots) {
		checkReferenceSlots();
	}
	if ($oop == 0) {
/*if[MACROIZE]*/
/*              --- TEST: fatalInterpreterError("NPE, time to freak out!");*/
		goto throw_nullPointerException;
/*else[MACROIZE]*/
//		resetStackPointerIfRevParms();
//		call(com_sun_squawk_VM_nullPointerException);
//		nextbytecode();
/*end[MACROIZE]*/
	}
}

/**
 * Check for a null pointer.
 *
 * @param oop the pointer
 */
/*DEF*/ void nullCheck(Address $oop) {
	nullCheckPrim($oop, true);
}

/**
 * Check for a null pointer or an array bounds overflow.
 *
 * @param oop the array
 * @param index the index to check
 */
/*DEF*/ void boundsCheck(Address $oop, int $index) {
	int lth;
	nullCheck($oop);
	lth = (int)getArrayLength($oop);
	/* use the unsigned bounds check trick: */
	if ((unsigned int) $index >= (unsigned int)lth) {
		/*  ($index < 0 || $index >= lth) */
/*if[MACROIZE]*/
		com_sun_squawk_VM_reportedIndex = $index;
		com_sun_squawk_VM_reportedArray = $oop;
		goto throw_arrayIndexOutOfBoundsException;
/*else[MACROIZE]*/
//		resetStackPointerIfRevParms();
//		call(com_sun_squawk_VM_arrayIndexOutOfBoundsException);
//		nextbytecode();
/*end[MACROIZE]*/
	}
}

/**
 * Gets the object that a putfield or getfield instruction operates on.
 *
 * @param oopIn0  specifies if the object whose field to be accessed is
 *                in parameter 0 or is on the stack
 * @return the object
 */
/*DEF*/ Address getInstanceFieldOop(boolean $oopIn0) {
	return $oopIn0 ? (Address)getParmTyped(0, AddressType_REF) : popAddress();
}

/*-----------------------------------------------------------------------*\
 *                         Instance field loads                          *
 \*-----------------------------------------------------------------------*/

/**
 * Loads a value from an int or long instance field that is being used
 * as an Address, UWord or Offset.
 *
 * @param oop   the object containing the field
 * @param flag  return immediately if false
 */
/*DEF*/ void getfield_ref_or_uword(Address $oop, boolean $flag) {
	if (TYPEMAP && $flag) {
		if (getMutationType() == AddressType_REF) {
			pushAddress(getObject($oop, iparm_g));
			nextbytecode(); /* completes instruction execution */
		}
		if (getMutationType() == AddressType_UWORD) {
			pushWord(getUWord($oop, iparm_g));
			nextbytecode(); /* completes instruction execution */
		}
	}
	/*
	 * The field really stores an int or long and so fall back to the
	 * properly typed way of loading these values
	 */
}

/**
 * Loads a value from a byte instance field.
 *
 * <p>
 * Java Stack: ..., OOP -> ..., VALUE  (if oopIn0 is false)
 * <p>
 * Java Stack: ..., -> ..., VALUE  (if oopIn0 is true)
 * <p>
 *
 * @param oopIn0  specifies if the object whose field to be loaded is
 *                in parameter 0 or is on the stack
 */
/*MAC*/ void do_getfield_b(boolean $oopIn0) {
	Address oop = getInstanceFieldOop($oopIn0);
	nullCheckPrim(oop, true);
	pushInt(getByte(oop, iparm_g));
}

/**
 * Loads a value from a short instance field.
 *
 * <p>
 * Java Stack: ..., OOP -> ..., VALUE  (if oopIn0 is false)
 * <p>
 * Java Stack: ..., -> ..., VALUE  (if oopIn0 is true)
 * <p>
 *
 * @param oopIn0  specifies if the object whose field to be loaded is
 *                in parameter 0 or is on the stack
 */
/*MAC*/ void do_getfield_s(boolean $oopIn0) {
	Address oop = getInstanceFieldOop($oopIn0);
	nullCheckPrim(oop, true);
	pushInt(getShort(oop, iparm_g));
}

/**
 * Loads a value from a char instance field.
 *
 * <p>
 * Java Stack: ..., OOP -> ..., VALUE  (if oopIn0 is false)
 * <p>
 * Java Stack: ..., -> ..., VALUE  (if oopIn0 is true)
 * <p>
 *
 * @param oopIn0  specifies if the object whose field to be loaded is
 *                in parameter 0 or is on the stack
 */
/*MAC*/ void do_getfield_c(boolean $oopIn0) {
	Address oop = getInstanceFieldOop($oopIn0);
	nullCheckPrim(oop, true);
	pushInt(getUShort(oop, iparm_g));
}

/**
 * Loads a value from an int instance field.
 *
 * <p>
 * Java Stack: ..., OOP -> ..., VALUE  (if oopIn0 is false)
 * <p>
 * Java Stack: ..., -> ..., VALUE  (if oopIn0 is true)
 * <p>
 *
 * @param oopIn0  specifies if the object whose field to be loaded is
 *                in parameter 0 or is on the stack
 */
/*MAC*/ void do_getfield_i(boolean $oopIn0) {
	Address oop = getInstanceFieldOop($oopIn0);
	nullCheckPrim(oop, true);
	getfield_ref_or_uword(oop, !SQUAWK_64);
	pushInt(getInt(oop, iparm_g));
}

/**
 * Loads a value from an object instance field.
 *
 * <p>
 * Java Stack: ..., OOP -> ..., VALUE  (if oopIn0 is false)
 * <p>
 * Java Stack: ..., -> ..., VALUE  (if oopIn0 is true)
 * <p>
 *
 * @param oopIn0  specifies if the object whose field to be loaded is
 *                in parameter 0 or is on the stack
 */
/*MAC*/ void do_getfield_o(boolean $oopIn0) {
	Address oop = getInstanceFieldOop($oopIn0);
	nullCheckPrim(oop, true);
	pushAddress(getObject(oop, iparm_g));
}

/**
 * Loads a value from a long instance field.
 *
 * <p>
 * Java Stack: ..., OOP -> ..., VALUE  (if oopIn0 is false)
 * <p>
 * Java Stack: ..., -> ..., VALUE  (if oopIn0 is true)
 * <p>
 *
 * @param oopIn0  specifies if the object whose field to be loaded is
 *                in parameter 0 or is on the stack
 */
/*MAC*/ void do_getfield_l(boolean $oopIn0) {
	Address oop = getInstanceFieldOop($oopIn0);
	nullCheckPrim(oop, true);
	getfield_ref_or_uword(oop, SQUAWK_64);
	pushLong(getLongAtWord(oop, iparm_g));
}

/*if[FLOATS]*/
/**
 * Loads a value from a float instance field.
 *
 * <p>
 * Java Stack: ..., OOP -> ..., VALUE  (if oopIn0 is false)
 * <p>
 * Java Stack: ..., -> ..., VALUE  (if oopIn0 is true)
 * <p>
 *
 * @param oopIn0  specifies if the object whose field to be loaded is
 *                in parameter 0 or is on the stack
 */
/*MAC*/ void do_getfield_f(boolean $oopIn0) {
	Address oop = getInstanceFieldOop($oopIn0);
	nullCheckPrim(oop, true);
	pushInt(getInt(oop, iparm_g));
}

/**
 * Loads a value from a double instance field.
 *
 * <p>
 * Java Stack: ..., OOP -> ..., VALUE  (if oopIn0 is false)
 * <p>
 * Java Stack: ..., -> ..., VALUE  (if oopIn0 is true)
 * <p>
 *
 * @param oopIn0  specifies if the object whose field to be loaded is
 *                in parameter 0 or is on the stack
 */
/*MAC*/ void do_getfield_d(boolean $oopIn0) {
	Address oop = getInstanceFieldOop($oopIn0);
	nullCheckPrim(oop, true);
	pushLong(getLongAtWord(oop, iparm_g));
}
/*end[FLOATS]*/

/*-----------------------------------------------------------------------*\
 *                         Instance field stores                         *
 \*-----------------------------------------------------------------------*/

/**
 * Stores a value to an int or long instance field that is being used
 * as an Address, UWord or Offset.
 *
 * @param oopIn0  specifies if the object whose field to be loaded is
 *                in parameter 0 or is on the stack
 */
/*DEF*/ void putfield_ref_or_uword(boolean $oopIn0, boolean $flag) {
	if (TYPEMAP && $flag) {
		if (getMutationType() == AddressType_REF) {
			Address value = popAddress();
			Address oop = getInstanceFieldOop($oopIn0);
			nullCheckPrim(oop, !$oopIn0);
			setObject(oop, iparm_g, value);
			nextbytecode();
		} else if (getMutationType() == AddressType_UWORD) {
			UWord value = popWord();
			Address oop = getInstanceFieldOop($oopIn0);
			nullCheckPrim(oop, !$oopIn0);
			setUWord(oop, iparm_g, value);
			nextbytecode();
		}
	}
}

/**
 * Stores a value to a byte instance field.
 *
 * <p>
 * Java Stack: ..., OOP, VALUE -> ...,  (if oopIn0 is false)
 * <p>
 * Java Stack: ..., VALUE -> ...,  (if oopIn0 is true)
 * <p>
 *
 * @param oopIn0  specifies if the object whose field to be loaded is
 *                in parameter 0 or is on the stack
 */
/*MAC*/ void do_putfield_b(boolean $oopIn0) {
	int value = popInt();
	Address oop = getInstanceFieldOop($oopIn0);
	nullCheckPrim(oop, !$oopIn0);
	setByte(oop, iparm_g, value);
}

/**
 * Stores a value to a short or char instance field.
 *
 * <p>
 * Java Stack: ..., OOP, VALUE -> ...,  (if oopIn0 is false)
 * <p>
 * Java Stack: ..., VALUE -> ...,  (if oopIn0 is true)
 * <p>
 *
 * @param oopIn0  specifies if the object whose field to be loaded is
 *                in parameter 0 or is on the stack
 */
/*MAC*/ void do_putfield_s(boolean $oopIn0) {
	int value = popInt();
	Address oop = getInstanceFieldOop($oopIn0);
	nullCheckPrim(oop, !$oopIn0);
	setShort(oop, iparm_g, value);
}

/**
 * Stores a value to an int instance field.
 *
 * <p>
 * Java Stack: ..., OOP, VALUE -> ...,  (if oopIn0 is false)
 * <p>
 * Java Stack: ..., VALUE -> ...,  (if oopIn0 is true)
 * <p>
 *
 * @param oopIn0  specifies if the object whose field to be loaded is
 *                in parameter 0 or is on the stack
 */
/*MAC*/ void do_putfield_i(boolean $oopIn0) {
	putfield_ref_or_uword($oopIn0, !SQUAWK_64);
	{
		int value = popInt();
		Address oop = getInstanceFieldOop($oopIn0);
		nullCheckPrim(oop, !$oopIn0);
		setInt(oop, iparm_g, value);
	}
}

/**
 * Stores a value to an object instance field.
 *
 * <p>
 * Java Stack: ..., OOP, VALUE -> ...,  (if oopIn0 is false)
 * <p>
 * Java Stack: ..., VALUE -> ...,  (if oopIn0 is true)
 * <p>
 *
 * @param oopIn0  specifies if the object whose field to be loaded is
 *                in parameter 0 or is on the stack
 */
/*MAC*/ void do_putfield_o(boolean $oopIn0) {
	Address value = popAddress();
	Address oop = getInstanceFieldOop($oopIn0);
	nullCheckPrim(oop, !$oopIn0);
	setObjectAndUpdateWriteBarrier(oop, iparm_g, value);
}

/**
 * Stores a value to a long instance field.
 *
 * <p>
 * Java Stack: ..., OOP, VALUE -> ...,  (if oopIn0 is false)
 * <p>
 * Java Stack: ..., VALUE -> ...,  (if oopIn0 is true)
 * <p>
 *
 * @param oopIn0  specifies if the object whose field to be loaded is
 *                in parameter 0 or is on the stack
 */
/*MAC*/ void do_putfield_l(boolean $oopIn0) {
	putfield_ref_or_uword($oopIn0, SQUAWK_64);
	{
		jlong value = popLong();
		Address oop = getInstanceFieldOop($oopIn0);
		nullCheckPrim(oop, !$oopIn0);
		setLongAtWord(oop, iparm_g, value);
	}
}

/*if[FLOATS]*/
/**
 * Stores a value to a float instance field.
 *
 * <p>
 * Java Stack: ..., OOP, VALUE -> ...,  (if oopIn0 is false)
 * <p>
 * Java Stack: ..., VALUE -> ...,  (if oopIn0 is true)
 * <p>
 *
 * @param oopIn0  specifies if the object whose field to be loaded is
 *                in parameter 0 or is on the stack
 */
/*MAC*/ void do_putfield_f(boolean $oopIn0) {
	int value = popInt();
	Address oop = getInstanceFieldOop($oopIn0);
	nullCheckPrim(oop, !$oopIn0);
	setInt(oop, iparm_g, value);
}

/**
 * Stores a value to a double instance field.
 *
 * <p>
 * Java Stack: ..., OOP, VALUE -> ...,  (if oopIn0 is false)
 * <p>
 * Java Stack: ..., VALUE -> ...,  (if oopIn0 is true)
 * <p>
 *
 * @param oopIn0  specifies if the object whose field to be loaded is
 *                in parameter 0 or is on the stack
 */
/*MAC*/ void do_putfield_d(boolean $oopIn0) {
	jlong value = popLong();
	Address oop = getInstanceFieldOop($oopIn0);
	nullCheckPrim(oop, !$oopIn0);
	setLongAtWord(oop, iparm_g, value);
}
/*end[FLOATS]*/

/*-----------------------------------------------------------------------*\
 *                           Array loads                                 *
 \*-----------------------------------------------------------------------*/

/**
 * Loads a value from an int or long array that is being used to store Address,
 * UWord or Offset values.
 *
 * @param index  the index of the element to load
 * @param oop    the address of the array
 * @param flag   return immediately if false
 */
/*DEF*/ void aload_ref_or_uword(int $index, Address $oop, boolean $flag) {
	if (TYPEMAP && $flag) {
		if (getMutationType() == AddressType_REF) {
			pushAddress(getObject($oop, $index));
			nextbytecode();
		}
		if (getMutationType() == AddressType_UWORD) {
			pushWord(getUWord($oop, $index));
			nextbytecode();
		}
	}
}

/**
 * Loads an element from a byte array.
 *
 * <p>
 * Java Stack: ..., OOP, INT -> ..., VALUE
 * <p>
 */
/*MAC*/ void do_aload_b() {
	int index   = popInt();
	Address oop = popAddress();
	boundsCheck(oop, index);
	pushInt(getByte(oop, index));
}

/**
 * Loads an element from a short array.
 *
 * <p>
 * Java Stack: ..., OOP, INT -> ..., VALUE
 * <p>
 */
/*MAC*/ void do_aload_s() {
	int index   = popInt();
	Address oop = popAddress();
	boundsCheck(oop, index);
	pushInt(getShort(oop, index));
}

/**
 * Loads an element from a char array.
 *
 * <p>
 * Java Stack: ..., OOP, INT -> ..., VALUE
 * <p>
 */
/*MAC*/ void do_aload_c() {
	int index   = popInt();
	Address oop = popAddress();
	boundsCheck(oop, index);
	pushInt(getUShort(oop, index));
}

/**
 * Loads an element from an integer array.
 *
 * <p>
 * Java Stack: ..., OOP, INT -> ..., VALUE
 * <p>
 */
/*MAC*/ void do_aload_i() {
	int index   = popInt();
	Address oop = popAddress();
	boundsCheck(oop, index);
	aload_ref_or_uword(index, oop, !SQUAWK_64);
	pushInt(getInt(oop, index));
}

/**
 * Loads an element from an object array.
 *
 * <p>
 * Java Stack: ..., OOP, INT -> ..., VALUE
 * <p>
 */
/*MAC*/ void do_aload_o() {
	int index   = popInt();
	Address oop = popAddress();
	boundsCheck(oop, index);
	pushAddress(getObject(oop, index));
}

/**
 * Loads an element from a long array.
 *
 * <p>
 * Java Stack: ..., OOP, INT -> ..., VALUE
 * <p>
 */
/*MAC*/ void do_aload_l() {
	int index   = popInt();
	Address oop = popAddress();
	boundsCheck(oop, index);
	aload_ref_or_uword(index, oop, SQUAWK_64);
	pushLong(getLong(oop, index));
}

/*if[FLOATS]*/
/**
 * Loads an element from a float array.
 *
 * <p>
 * Java Stack: ..., OOP, INT -> ..., VALUE
 * <p>
 */
/*MAC*/ void do_aload_f() {
	int index   = popInt();
	Address oop = popAddress();
	boundsCheck(oop, index);
	pushInt(getInt(oop, index));
}

/**
 * Loads an element from a double array.
 *
 * <p>
 * Java Stack: ..., OOP, INT -> ..., VALUE
 * <p>
 */
/*MAC*/ void do_aload_d() {
	int index   = popInt();
	Address oop = popAddress();
	boundsCheck(oop, index);
	pushLong(getLong(oop, index));
}
/*end[FLOATS]*/

/*-----------------------------------------------------------------------*\
 *                           Array stores                                *
 \*-----------------------------------------------------------------------*/

/*DEF*/ void astore_ref_or_word() {
	if (TYPEMAP) {
		if (getMutationType() == AddressType_REF) {
			Address value = popAddress();
			int index   = popInt();
			Address oop = popAddress();
			boundsCheck(oop, index);
			setObject(oop, index, value);
			nextbytecode();
		} else if (getMutationType() == AddressType_UWORD) {
			UWord value = popWord();
			int index   = popInt();
			Address oop = popAddress();
			boundsCheck(oop, index);
			setUWord(oop, index, value);
			nextbytecode();
		}
	}
}

/**
 * Stores an element to a byte array.
 *
 * <p>
 * Java Stack: ..., OOP, INT, VALUE -> ...
 * <p>
 */
/*MAC*/ void do_astore_b() {
	int value   = popInt();
	int index   = popInt();
	Address oop = popAddress();
	boundsCheck(oop, index);
	setByte(oop, index, value);
}

/**
 * Stores an element to a short array.
 *
 * <p>
 * Java Stack: ..., OOP, INT, VALUE -> ...
 * <p>
 */
/*MAC*/ void do_astore_s() {
	int value   = popInt();
	int index   = popInt();
	Address oop = popAddress();
	boundsCheck(oop, index);
	setShort(oop, index, value);
}

/**
 * Stores an element to an int array.
 *
 * <p>
 * Java Stack: ..., OOP, INT, VALUE -> ...
 * <p>
 */
/*MAC*/ void do_astore_i() {
	astore_ref_or_word();
	{
		int value   = popInt();
		int index   = popInt();
		Address oop = popAddress();
		boundsCheck(oop, index);
		setInt(oop, index, value);
	}
}

/**
 * Stores an element to a long array.
 *
 * <p>
 * Java Stack: ..., OOP, INT, VALUE -> ...
 * <p>
 */
/*MAC*/ void do_astore_l() {
	astore_ref_or_word();
	{
		jlong value = popLong();
		int index   = popInt();
		Address oop = popAddress();
		boundsCheck(oop, index);
		setLong(oop, index, value);
	}
}

/**
 * Stores an element to an object array.
 *
 * <p>
 * Java Stack:      OOP, INT, VALUE -> _
 * <p>
 */
/*MAC*/ void do_astore_o() {
	Address value  = popAddress();
	int index   = popInt();
	Address oop = popAddress();
	boundsCheck(oop, index);
	if ((value != 0)
	    && (com_sun_squawk_Klass_id(getClass(oop)) != CID_OBJECT_ARRAY)
	    && VM_arrayOopStoreCheck(oop, index, value)) {
		call(com_sun_squawk_VM_arrayStoreException);
	} else {
		setObjectAndUpdateWriteBarrier(oop, index, value);
	}
}

/*if[FLOATS]*/
/**
 * Stores an element to a float array.
 *
 * <p>
 * Java Stack: ..., OOP, INT, VALUE -> ...
 * <p>
 */
/*MAC*/ void do_astore_f() {
	int value   = popInt();
	int index   = popInt();
	Address oop = popAddress();
	boundsCheck(oop, index);
	setInt(oop, index, value);
}

/**
 * Stores an element to a double array.
 *
 * <p>
 * Java Stack: ..., OOP, INT, VALUE -> ...
 * <p>
 */
/*MAC*/ void do_astore_d() {
	jlong value = popLong();
	int index   = popInt();
	Address oop = popAddress();
	boundsCheck(oop, index);
	setLong(oop, index, value);
}
/*end[FLOATS]*/

/*-----------------------------------------------------------------------*\
 *                           Invoke instructions                         *
 \*-----------------------------------------------------------------------*/

/**
 * invokestatic.
 *
 * Java Stack: [[... arg2], arg1], CLASS -> [VALUE]
 * <p>
 */
/*MAC*/ void do_invokestatic() {
	Address cls = popAddress();
	call(getStaticMethod(cls, iparm_g));
}

/**
 * invokesuper.
 *
 * Java Stack: [[... arg2], arg1], OOP, CLASS -> [VALUE]
 * <p>
 */
/*MAC*/ void do_invokesuper() {
	Address cls = popAddress();
	Address obj;
	resetStackPointerIfNotRevParms();
	obj = (Address)peek();
	nullCheck(obj);
	callNoReset(getVirtualMethod(cls, iparm_g));
}

/**
 * invokevirtual.
 *
 * Java Stack: [[... arg2], arg1], OOP -> [VALUE]
 * <p>
 */
/*MAC*/ void do_invokevirtual() {
	Address obj;
	Address cls;
	resetStackPointerIfNotRevParms();
	obj = (Address)peek();
	nullCheck(obj);
	assumeInterp(((UWord)getObject(obj, HDR_klass) & HDR_headerTagMask) == 0);
	cls = getClassOrAssociation(obj);
	callNoReset(getVirtualMethod(cls, iparm_g));
}

/**
 * findslot.
 *
 * <p>
 * Java Stack: OOP, CLASS -> VSLOT
 * <p>
 */
/*MAC*/ void do_findslot() {
	Address interfaceKlass = popAddress();
	Address oop = popAddress();
	int slot;

	nullCheck(oop);
	slot = VM_findSlot(oop, interfaceKlass, iparm_g);
	if (likely(slot >= 0)) {
		pushInt(slot);
	} else {
		call(com_sun_squawk_VM_abstractMethodError);
	}
}

/**
 * invokeslot.
 *
 * Java Stack: [[... arg2], arg1], OOP, VSLOT -> [VALUE] (Stack grows down)
 */
/*MAC*/ void do_invokeslot() {
	iparm_g = popInt();
	do_invokevirtual();
}


/*INL*/ void incExtends(int $slots) {
#if TRACE
	total_extends_g++;
	total_slots_g += $slots;
#endif
}


/**
 * Extends the call stack if necessary.
 *
 * <p>
 * Java Stack: _ -> _
 * <p>
 */
/*MAC*/ void extendStack(Address $mp, int $slotsToClear) {
	Address mp = $mp;
	int nlocals, nstack;
	assumeInterp(com_sun_squawk_VM_extendsEnabled);
	assumeInterp(inCode(mp));
	downPushAddress(fp_g);                      /* Save caller's frame pointer. */
	downPushAddress(mp);                        /* Method address.              */
	fp_g = sp_g;                                /* Setup new frame pointer.     */
	assumeInterp(getMP() == mp);
	nlocals = getLocalCount(mp);
	nstack  = getStackCount(mp);
	assumeInterp($slotsToClear < nlocals);
	incExtends($slotsToClear);
	if (likely((fp_g - nlocals - nstack) > (sl_g + FP_FIXED_FRAME_SIZE))) {
		UWordAddress oldsp = sp_g;
		int delta = nlocals;
/*if[REVERSE_PARAMETERS]*/
/*else[REVERSE_PARAMETERS]*/
//		delta += nstack;
/*end[REVERSE_PARAMETERS]*/
		resetStackPointerFromDelta(delta);
/*if[CHECK_SLOT_CLEARING]*/
		int slotsToZap = nlocals - 1;
		UWordAddress oldsp2 = oldsp;
		while (slotsToZap > 0) {
			setUWord(--oldsp2, 0, 0xDEAFBEEF);   /* Write a bad value */
			setType(oldsp2, AddressType_ANY, sizeof(UWord));
			slotsToZap = slotsToZap - 1;
		}
/*end[CHECK_SLOT_CLEARING]*/
		while ($slotsToClear > 0) {
			setUWord(--oldsp, 0, 0);             /* zero local variables that need clearing */
			setType(oldsp, AddressType_ANY, sizeof(UWord));
			$slotsToClear = $slotsToClear - 1;
		}
	} else {
		int overflow = (sl_g + FP_FIXED_FRAME_SIZE) - (fp_g - nlocals - nstack);
		assumeInterp(getUWord(ss_g, SC_guard) == 0);
/*if[DEBUG_CODE_ENABLED]*/
		if (com_sun_squawk_GC_traceFlags > 1) {
			fprintf(stderr, format(
				        "*** Extending stack *** (stack size=%d, remaining stack=%d, nlocals=%d, nstack=%d, slotsToClear=%d, mp=0x%x)\n"),
			        getArrayLength(ss_g),
			        sp_g - sl_g,
			        nlocals,
			        nstack,
			        $slotsToClear,
			        (int)mp
				);
		}
/*end[DEBUG_CODE_ENABLED]*/
		if (unlikely(usingServiceStack())) {
			fatalInterpreterError("cannot extend service stack");
		}
		if (unlikely(!com_sun_squawk_VM_extendsEnabled)) {
			fatalInterpreterError("trying to extend stack when extension disabled");
		}

		/* Pass the minimum amount (in words) by which the stack must grow. */
		com_sun_squawk_ServiceOperation_i1 = overflow;

		if (TRACE)
			printStackTracePrim(-1, ip_g, fp_g, "extending stack", null);

		if (unlikely(runningOnServiceThread_g))
			fatalInterpreterError("Cannot extend service stack from the service thread");

		threadSwitchFor(com_sun_squawk_ServiceOperation_EXTEND);
	}
}

/**
 * Extend the activation record.
 *
 * <p>
 * Java Stack: _ -> _
 * <p>
 */
/*MAC*/ void do_extend() {
	Address mp = Address_sub(ip_g, 2);
	extendStack(mp, iparm_g);
}

/**
 * Extend the activation record.
 *
 * <p>
 * Java Stack: _ -> _
 * <p>
 */
/*MAC*/ void do_extend0() {
	Address mp = Address_sub(ip_g, 1);
	extendStack(mp, 0);
}

/*-----------------------------------------------------------------------*\
 *                               Return                                  *
 \*-----------------------------------------------------------------------*/

/**
 * Executes a method return where the int or long value being returned is being used
 * as an Address, UWord or Offset.
 *
 * @param flag  return immediately if false
 */
/*DEF*/ void return_ref_or_uword(boolean $flag) {
	if (TYPEMAP && $flag) {
		if (getMutationType() == AddressType_REF) {
			Address res;
			ip_g = (ByteAddress)getObject(fp_g, FP_returnIP);
			res = popAddress();
			fp_g = (UWordAddress)getObject(fp_g, FP_returnFP);
			resetStackPointer();
			pushAddress(res);
			nextbytecode();
		}
		if (getMutationType() == AddressType_UWORD) {
			UWord res;
			ip_g = (ByteAddress)getObject(fp_g, FP_returnIP);
			res = popWord();
			fp_g = (UWordAddress)getObject(fp_g, FP_returnFP);
			resetStackPointer();
			pushWord(res);
			nextbytecode();
		}
	}
}

/**
 * Executes a return from a method that returns an int value.
 *
 * <p>
 * Java Stack: [VALUE] -> [VALUE]
 * <p>
 */
/*MAC*/ void do_return_i() {
	return_ref_or_uword(!SQUAWK_64);
	{
		int res = popInt();
		ip_g = (ByteAddress)getObject(fp_g, FP_returnIP);
		fp_g = (UWordAddress)getObject(fp_g, FP_returnFP);
		assumeInterp(inCode(ip_g));
		resetStackPointer();
		pushInt(res);
	}
}

/**
 * Executes a return from a method that returns a long value.
 *
 * <p>
 * Java Stack: [VALUE] -> [VALUE]
 * <p>
 */
/*MAC*/ void do_return_l() {
	return_ref_or_uword(SQUAWK_64);
	{
		jlong res = popLong();
		ip_g = (ByteAddress)getObject(fp_g, FP_returnIP);
		fp_g = (UWordAddress)getObject(fp_g, FP_returnFP);
		assumeInterp(inCode(ip_g));
		resetStackPointer();
		pushLong(res);
	}
}

/**
 * Executes a return from a method that returns an object value.
 *
 * <p>
 * Java Stack: [VALUE] -> [VALUE]
 * <p>
 */
/*MAC*/ void do_return_o() {
	Address res = popAddress();
	ip_g = (ByteAddress)getObject(fp_g, FP_returnIP);
	fp_g = (UWordAddress)getObject(fp_g, FP_returnFP);
	assumeInterp(inCode(ip_g));
	resetStackPointer();
	pushAddress(res);
}

/**
 * Executes a return from a method that does not return a value.
 *
 * <p>
 * Java Stack: [VALUE] -> _
 * <p>
 */
/*MAC*/ void do_return_v() {
	ip_g = (ByteAddress)getObject(fp_g, FP_returnIP);
	fp_g = (UWordAddress)getObject(fp_g, FP_returnFP);
	assumeInterp(inCode(ip_g));
	resetStackPointer();
}

/*if[FLOATS]*/
/**
 * Executes a return from a method that returns a float value.
 *
 * <p>
 * Java Stack: [VALUE] -> [VALUE]
 * <p>
 */
/*MAC*/ void do_return_f() {
	do_return_i();
}

/**
 * Executes a return from a method that returns a double value.
 *
 * <p>
 * Java Stack: [VALUE] -> [VALUE]
 * <p>
 */
/*MAC*/ void do_return_d() {
	do_return_l();
}
/*end[FLOATS]*/

/*-----------------------------------------------------------------------*\
 *                               Pop                                     *
 \*-----------------------------------------------------------------------*/

/**
 * Pops one word from the Java stack.
 *
 * <p>
 * Java Stack: ..., INT -> ...
 * <p>
 */
/*MAC*/ void do_pop_n(int $n) {
	(void)popAsType(AddressType_ANY);
	if (!SQUAWK_64 && $n == 2) {
		(void)popAsType(AddressType_ANY);
	}
}

/*-----------------------------------------------------------------------*\
 *                           Native methods                              *
 \*-----------------------------------------------------------------------*/

/*if[GC2C]*/
/**
 * These forward declarations have to be here to deal with the
 * different behaviour of GCC on the Mac with respect to forward
 * declarations of static methods.
 */
/*if[MICROBLAZE_BUILD]*/
extern Address copyObjectGraph(Address, Address, Address, Address);
/*else[MICROBLAZE_BUILD]*/
//      static Address copyObjectGraph(Address, Address, Address, Address);
/*end[MICROBLAZE_BUILD]*/
static int collectGarbage(Address, Address, int);
/*end[GC2C]*/

#if PLATFORM_TYPE_BARE_METAL
#define checkNativeCall(_ptr_) fatalInterpreterError("checkNativeCall")
#define endCheckNativeCall()
#else
#define checkNativeCall(_ptr_) nativeFuncPtr = _ptr_
#define endCheckNativeCall() nativeFuncPtr = NULL
#endif

/**
 * invokenativemain.
 */
/*MAC*/ void invokenativemain() {
	checkReferenceSlots();
	switch(iparm_g) {
	case Native_com_sun_squawk_Offset_eq:
	case Native_com_sun_squawk_UWord_eq: {
		UWord value2 = popWord();
		UWord value1 = popWord();
		pushInt(value1 == value2);
		break;
	}

	case Native_com_sun_squawk_Offset_ne:
	case Native_com_sun_squawk_UWord_ne: {
		UWord value2 = popWord();
		UWord value1 = popWord();
		pushInt(value1 != value2);
		break;
	}

	case Native_com_sun_squawk_Offset_add: {
		int delta = popInt();
		Offset offset = (Offset)popWord();
		pushWord(offset + delta);
		break;
	}

	case Native_com_sun_squawk_Offset_sub: {
		int delta = popInt();
		Offset offset = (Offset)popWord();
		pushWord(offset - delta);
		break;
	}

	case Native_com_sun_squawk_Offset_bytesToWords: {
		Offset offset = (Offset)popWord();
		assumeInterp((offset % HDR_BYTES_PER_WORD) == 0);
		pushWord(offset >> HDR_LOG2_BYTES_PER_WORD);
		break;
	}

	case Native_com_sun_squawk_Offset_wordsToBytes: {
		Offset offset = (Offset)popWord();
		pushWord(offset << HDR_LOG2_BYTES_PER_WORD);
		break;
	}

	case Native_com_sun_squawk_Address_fromPrimitive: {
		if (TYPEMAP) {
			UWord value = SQUAWK_64 ? popLong() : popInt();
			pushAddress((Address)value);
		}
		break;
	}

	case Native_com_sun_squawk_Offset_fromPrimitive:
	case Native_com_sun_squawk_UWord_fromPrimitive: {
		if (TYPEMAP) {
			UWord value = SQUAWK_64 ? popLong() : popInt();
			pushWord(value);
		}
		break;
	}

	case Native_com_sun_squawk_Offset_toPrimitive:
	case Native_com_sun_squawk_UWord_toPrimitive: {
		if (TYPEMAP) {
			UWord value = popWord();
			if (SQUAWK_64) {
				/* this catches a (false) assumption that a given offset won't loose its sign or magnitude when converted to a long */
				if (ASSUME && (jlong)value != value) {
					fatalInterpreterError("cast to long changes sign and/or magnitude");
				}
				pushLong(value);
			} else {
				/* this catches a (false) assumption that a given offset won't loose its sign or magnitude when converted to an int */
				if (ASSUME && (int)value != value) {
					fatalInterpreterError("cast to int changes sign and/or magnitude");
				}
				pushInt(value);
			}
		}
		break;
	}

	case Native_com_sun_squawk_Offset_toInt:
	case Native_com_sun_squawk_UWord_toInt: {
		if (TYPEMAP || SQUAWK_64 || ASSUME) {
			UWord value = popWord();
			/* this catches a (false) assumption that a given offset won't loose its sign or magnitude when converted to an int */
			if (ASSUME && (int)value != value) {
				fatalInterpreterError("cast to int changes sign and/or magnitude");
			}
			pushInt((int)value);
		}
		break;
	}

	case Native_com_sun_squawk_UWord_toOffset:
	case Native_com_sun_squawk_Offset_toUWord: {
		break;
	}

	case Native_com_sun_squawk_UWord_max: {
		pushWord(WORD_MAX);
		break;
	}

	case Native_com_sun_squawk_Offset_zero:
	case Native_com_sun_squawk_UWord_zero: {
		pushWord(0);
		break;
	}

	case Native_com_sun_squawk_UWord_and: {
		UWord value2 = popWord();
		UWord value1 = popWord();
		pushWord(value1 & value2);
		break;
	}

	case Native_com_sun_squawk_UWord_or: {
		UWord value2 = popWord();
		UWord value1 = popWord();
		pushWord(value1 | value2);
		break;
	}

	case Native_com_sun_squawk_UWord_loeq: {
		UWord value2 = popWord();
		UWord value1 = popWord();
		pushInt(loeq(value1, value2));
		break;
	}

	case Native_com_sun_squawk_UWord_hieq: {
		UWord value2 = popWord();
		UWord value1 = popWord();
		pushInt(hieq(value1, value2));
		break;
	}

	case Native_com_sun_squawk_UWord_hi: {
		UWord value2 = popWord();
		UWord value1 = popWord();
		pushInt(hi(value1, value2));
		break;
	}

	case Native_com_sun_squawk_UWord_lo: {
		UWord value2 = popWord();
		UWord value1 = popWord();
		pushInt(lo(value1, value2));
		break;
	}

	case Native_com_sun_squawk_Offset_le: {
		UWord value2 = popWord();
		UWord value1 = popWord();
		pushInt(le(value1, value2));
		break;
	}

	case Native_com_sun_squawk_Offset_ge: {
		UWord value2 = popWord();
		UWord value1 = popWord();
		pushInt(ge(value1, value2));
		break;
	}

	case Native_com_sun_squawk_Offset_gt: {
		UWord value2 = popWord();
		UWord value1 = popWord();
		pushInt(gt(value1, value2));
		break;
	}

	case Native_com_sun_squawk_Offset_lt: {
		UWord value2 = popWord();
		UWord value1 = popWord();
		pushInt(lt(value1, value2));
		break;
	}

	case Native_com_sun_squawk_Offset_isZero:
	case Native_com_sun_squawk_UWord_isZero: {
		UWord value = popWord();
		pushInt(value == 0);
		break;
	}

	case Native_com_sun_squawk_UWord_isMax: {
		UWord value = popWord();
		pushInt(value == WORD_MAX);
		break;
	}

	case Native_com_sun_squawk_NativeUnsafe_getAsByte:
		if (TYPEMAP) {
			int     off = popInt();
			Address base = popAddress();
			pushInt(getByteTyped(base, off, AddressType_ANY));
			break;
		} else {
			/* fall-through... */
		}
	case Native_com_sun_squawk_NativeUnsafe_getByte: {
		int     off = popInt();
		Address base = popAddress();
		pushInt(getByte(base, off));
		break;
	}

	case Native_com_sun_squawk_NativeUnsafe_setByte: {
		int     val = popInt();
		int     off = popInt();
		Address base = popAddress();
		setByte(base, off, val);
		break;
	}

	case Native_com_sun_squawk_NativeUnsafe_getAsShort:
		if (TYPEMAP) {
			int     off = popInt();
			Address base = popAddress();
			pushInt(getShortTyped(base, off, AddressType_ANY));
			break;
		} else {
			/* fall-through... */
		}
	case Native_com_sun_squawk_NativeUnsafe_getShort: {
		int     off = popInt();
		Address base = popAddress();
		pushInt(getShort(base, off));
		break;
	}

	case Native_com_sun_squawk_NativeUnsafe_getChar: {
		int     off = popInt();
		Address base = popAddress();
		pushInt(getUShort(base, off));
		break;
	}

	case Native_com_sun_squawk_NativeUnsafe_charAt: {
		int     off = popInt();
		Address str = popAddress();
		Address cls = getClass(str);
		boundsAssume(str, off);
		if (com_sun_squawk_Klass_id(cls) == com_sun_squawk_StringOfBytes) {
			pushInt(getUByte(str, off));
		} else {
			pushInt(getUShort(str, off));
		}
		break;
	}

	case Native_com_sun_squawk_NativeUnsafe_setShort:
	case Native_com_sun_squawk_NativeUnsafe_setChar: {
		int     val = popInt();
		int     off = popInt();
		Address base = popAddress();
		setShort(base,  off, val);
		break;
	}

	case Native_com_sun_squawk_NativeUnsafe_getAddress:
	case Native_com_sun_squawk_NativeUnsafe_getObject: {
		int     off = popInt();
		Address base = popAddress();
		pushAddress(getObject(base, off));
		break;
	}

	case Native_com_sun_squawk_NativeUnsafe_getAsUWord:
		if (TYPEMAP) {
			int     off = popInt();
			Address base = popAddress();
			pushWord(getUWordTyped(base, off, AddressType_ANY));
			break;
		} else {
			/* fall-through... */
		}
	case Native_com_sun_squawk_NativeUnsafe_getUWord: {
		int     off = popInt();
		Address base = popAddress();
		pushWord(getUWord(base, off));
		break;
	}

	case Native_com_sun_squawk_NativeUnsafe_getAsInt:
		if (TYPEMAP) {
			int     off = popInt();
			Address base = popAddress();
			pushInt(getIntTyped(base, off, AddressType_ANY));
			break;
		} else {
			/* fall-through... */
		}
	case Native_com_sun_squawk_NativeUnsafe_getInt: {
		int     off = popInt();
		Address base = popAddress();
		pushInt(getInt(base, off));
		break;
	}

	case Native_com_sun_squawk_NativeUnsafe_getUnalignedInt: {
		int     byte_off = popInt();
		Address base = popAddress();
		pushInt(getUnalignedInt(base, byte_off));
		break;
	}

	case Native_com_sun_squawk_NativeUnsafe_getUnalignedLong: {
		int     byte_off = popInt();
		Address base = popAddress();
		pushLong(getUnalignedLong(base, byte_off));
		break;
	}

	case Native_com_sun_squawk_NativeUnsafe_getUnalignedShort: {
		int     byte_off = popInt();
		Address base = popAddress();
		pushInt(getUnalignedShort(base, byte_off));
		break;
	}

	case Native_com_sun_squawk_NativeUnsafe_malloc: {
		int     size = popWord();
		pushAddress(malloc(size));
		break;
	}

	case Native_com_sun_squawk_NativeUnsafe_free: {
		Address base = popAddress();
		free(base);
		break;
	}

	case Native_com_sun_squawk_NativeUnsafe_setAddress: {
		Address val = popAddress();
		int     off = popInt();
		Address base = popAddress();
		setObject(base,  off, val);
		break;
	}

	case Native_com_sun_squawk_NativeUnsafe_setObject: {
		Address val = popAddress();
		int     off = popInt();
		Address base = popAddress();
		setObjectAndUpdateWriteBarrier(base,  off, val);
		break;
	}

	case Native_com_sun_squawk_NativeUnsafe_setInt: {
		int     val = popInt();
		int     off = popInt();
		Address base = popAddress();
		setInt(base,  off, val);
		break;
	}

	case Native_com_sun_squawk_NativeUnsafe_setUWord: {
		UWord    val = popWord();
		int     off = popInt();
		Address base = popAddress();
		setUWord(base,  off, val);
		break;
	}

	case Native_com_sun_squawk_NativeUnsafe_getLong: {
		int     off = popInt();
		Address base = popAddress();
		pushLong(getLong(base, off));
		break;
	}

	case Native_com_sun_squawk_NativeUnsafe_setLong: {
		jlong   val = popLong();
		int     off = popInt();
		Address base = popAddress();
		setLong(base,  off, val);
		break;
	}

	case Native_com_sun_squawk_NativeUnsafe_getLongAtWord: {
		int     off = popInt();
		Address base = popAddress();
		pushLong(getLongAtWord(base, off));
		break;
	}

	case Native_com_sun_squawk_NativeUnsafe_setLongAtWord: {
		jlong   val = popLong();
		int     off = popInt();
		Address base = popAddress();
		setLongAtWord(base,  off, val);
		break;
	}

	case Native_com_sun_squawk_NativeUnsafe_setUnalignedShort: {
		int     val = popInt();
		int     byte_off = popInt();
		Address base = popAddress();
		setUnalignedShort(base, byte_off, val);
		break;
	}

	case Native_com_sun_squawk_NativeUnsafe_setUnalignedInt: {
		int     val = popInt();
		int     byte_off = popInt();
		Address base = popAddress();
		setUnalignedInt(base, byte_off, val);
		break;
	}

	case Native_com_sun_squawk_NativeUnsafe_setUnalignedLong: {
		jlong   val = popLong();
		int     byte_off = popInt();
		Address base = popAddress();
		setUnalignedLong(base, byte_off, val);
		break;
	}

	case Native_com_sun_squawk_NativeUnsafe_swap: {
		int dataSize = popInt();
		Address address = popAddress();
		swap(address, dataSize);
		break;
	}

	case Native_com_sun_squawk_NativeUnsafe_swap2: {
		Address address = popAddress();
		swap2(address);
		break;
	}

	case Native_com_sun_squawk_NativeUnsafe_swap4: {
		Address address = popAddress();
		swap4(address);
		break;
	}

	case Native_com_sun_squawk_NativeUnsafe_swap8: {
		Address address = popAddress();
		swap8(address);
		break;
	}

/* DO WE WANT TO SUPPORT NATIVEUNSAFE_CALLS IN BARE_METAL SYSTEMS???? */
	case Native_com_sun_squawk_NativeUnsafe_call0: {
		Address address = popAddress();
		funcPtr0 fptr = (funcPtr0)address;
		int result;
		checkNativeCall(fptr);
		result = (*fptr)();
/*if[!MICROBLAZE_BUILD]*/
		set_com_sun_squawk_VMThread_errno(com_sun_squawk_VMThread_currentThread, errno);
/*else[MICROBLAZE_BUILD]*/
//			fprintf("NATIVE UNSAFE CALL at %s:%d\n", __FILE__, __LINE__);
/*end[MICROBLAZE_BUILD]*/
		endCheckNativeCall();
		pushInt(result);
		break;
	}

	case Native_com_sun_squawk_NativeUnsafe_call1: {
		int i1 = popInt();
		Address address = popAddress();
		funcPtr1 fptr = (funcPtr1)address;
		int result;
		checkNativeCall(fptr);
		result = (*fptr)(i1);
/*if[!MICROBLAZE_BUILD]*/
		set_com_sun_squawk_VMThread_errno(com_sun_squawk_VMThread_currentThread, errno);
/*else[MICROBLAZE_BUILD]*/
//			fprintf("NATIVE UNSAFE CALL at %s:%d\n", __FILE__, __LINE__);
/*end[MICROBLAZE_BUILD]*/
		endCheckNativeCall();
		pushInt(result);
		break;
	}

	case Native_com_sun_squawk_NativeUnsafe_call2: {
		int i2 = popInt();
		int i1 = popInt();
		Address address = popAddress();
		funcPtr2 fptr = (funcPtr2)address;
		int result;
		checkNativeCall(fptr);
		result = (*fptr)(i1, i2);
/*if[!MICROBLAZE_BUILD]*/
		set_com_sun_squawk_VMThread_errno(com_sun_squawk_VMThread_currentThread, errno);
/*else[MICROBLAZE_BUILD]*/
//			fprintf("NATIVE UNSAFE CALL at %s:%d\n", __FILE__, __LINE__);
/*end[MICROBLAZE_BUILD]*/
		endCheckNativeCall();
		pushInt(result);
		break;
	}

	case Native_com_sun_squawk_NativeUnsafe_call3: {
		int i3 = popInt();
		int i2 = popInt();
		int i1 = popInt();
		Address address = popAddress();
		funcPtr3 fptr = (funcPtr3)address;
		int result;
		checkNativeCall(fptr);
		result = (*fptr)(i1, i2, i3);
/*if[!MICROBLAZE_BUILD]*/
		set_com_sun_squawk_VMThread_errno(com_sun_squawk_VMThread_currentThread, errno);
/*else[MICROBLAZE_BUILD]*/
//			fprintf("NATIVE UNSAFE CALL at %s:%d\n", __FILE__, __LINE__);
/*end[MICROBLAZE_BUILD]*/
		endCheckNativeCall();
		pushInt(result);
		break;
	}

	case Native_com_sun_squawk_NativeUnsafe_call4: {
		int i4 = popInt();
		int i3 = popInt();
		int i2 = popInt();
		int i1 = popInt();
		Address address = popAddress();
		funcPtr4 fptr = (funcPtr4)address;
		int result;
		checkNativeCall(fptr);
		result = (*fptr)(i1, i2, i3, i4);
/*if[!MICROBLAZE_BUILD]*/
		set_com_sun_squawk_VMThread_errno(com_sun_squawk_VMThread_currentThread, errno);
/*else[MICROBLAZE_BUILD]*/
//			fprintf("NATIVE UNSAFE CALL at %s:%d\n", __FILE__, __LINE__);
/*end[MICROBLAZE_BUILD]*/
		endCheckNativeCall();
		pushInt(result);
		break;
	}

	case Native_com_sun_squawk_NativeUnsafe_call5: {
		int i5 = popInt();
		int i4 = popInt();
		int i3 = popInt();
		int i2 = popInt();
		int i1 = popInt();
		Address address = popAddress();
		funcPtr5 fptr = (funcPtr5)address;
		int result;
		checkNativeCall(fptr);
		result = (*fptr)(i1, i2, i3, i4, i5);
/*if[!MICROBLAZE_BUILD]*/
		set_com_sun_squawk_VMThread_errno(com_sun_squawk_VMThread_currentThread, errno);
/*else[MICROBLAZE_BUILD]*/
//			fprintf("NATIVE UNSAFE CALL at %s:%d\n", __FILE__, __LINE__);
/*end[MICROBLAZE_BUILD]*/
		endCheckNativeCall();
		pushInt(result);
		break;
	}

	case Native_com_sun_squawk_NativeUnsafe_call6: {
		int i6 = popInt();
		int i5 = popInt();
		int i4 = popInt();
		int i3 = popInt();
		int i2 = popInt();
		int i1 = popInt();
		Address address = popAddress();
		funcPtr6 fptr = (funcPtr6)address;
		int result;
		checkNativeCall(fptr);
		result = (*fptr)(i1, i2, i3, i4, i5, i6);
/*if[!MICROBLAZE_BUILD]*/
		set_com_sun_squawk_VMThread_errno(com_sun_squawk_VMThread_currentThread, errno);
/*else[MICROBLAZE_BUILD]*/
//			fprintf("NATIVE UNSAFE CALL at %s:%d\n", __FILE__, __LINE__);
/*end[MICROBLAZE_BUILD]*/
		endCheckNativeCall();
		pushInt(result);
		break;
	}

		/* yes, jump straight to 10... */
	case Native_com_sun_squawk_NativeUnsafe_call10: {
		int i10 = popInt();
		int i9 = popInt();
		int i8 = popInt();
		int i7 = popInt();
		int i6 = popInt();
		int i5 = popInt();
		int i4 = popInt();
		int i3 = popInt();
		int i2 = popInt();
		int i1 = popInt();
		Address address = popAddress();
		funcPtr10 fptr = (funcPtr10)address;
		int result;
		checkNativeCall(fptr);
		result = (*fptr)(i1, i2, i3, i4, i5, i6, i7, i8, i9, i10);
/*if[!MICROBLAZE_BUILD]*/
		set_com_sun_squawk_VMThread_errno(com_sun_squawk_VMThread_currentThread, errno);
/*else[MICROBLAZE_BUILD]*/
//			fprintf("NATIVE UNSAFE CALL at %s:%d\n", __FILE__, __LINE__);
/*end[MICROBLAZE_BUILD]*/
		endCheckNativeCall();
		pushInt(result);
		break;
	}

		/* BARE_METAL platforms don't support native threads, so can't support TaskExecutors */
/*if[!PLATFORM_TYPE_BARE_METAL]*/
	case Native_com_sun_squawk_NativeUnsafe_createTaskExecutor: {
		int stacksize = popInt();
		int priority = popInt();
		Address nameAddr = popAddress();
		char* name = (char*)nameAddr;
		Address result;
		result = createTaskExecutor(name, priority, stacksize);
		pushAddress(result);
		break;
	}

	case Native_com_sun_squawk_NativeUnsafe_cancelTaskExecutor: {
		TaskExecutor* te = (TaskExecutor*)popAddress();
		cancelTaskExecutor(te);
		pushInt(0);
		break;
	}

	case Native_com_sun_squawk_NativeUnsafe_deleteTaskExecutor: {
		TaskExecutor* te = (TaskExecutor*)popAddress();
		pushInt(deleteTaskExecutor(te));
		break;
	}

	case Native_com_sun_squawk_NativeUnsafe_deleteNativeTask: {
		NativeTask* ntask = (NativeTask*)popAddress();
		deleteNativeTask(ntask);
		pushInt(0);
		break;
	}

	case Native_com_sun_squawk_NativeUnsafe_runBlockingFunctionOn: {
		int i10 = popInt();
		int i9 = popInt();
		int i8 = popInt();
		int i7 = popInt();
		int i6 = popInt();
		int i5 = popInt();
		int i4 = popInt();
		int i3 = popInt();
		int i2 = popInt();
		int i1 = popInt();
		Address address = popAddress();
		funcPtr10 fptr = (funcPtr10)address;
		Address te = popAddress();
		Address result;
		result = runBlockingFunctionOn(te, fptr, i1, i2, i3, i4, i5, i6, i7, i8, i9, i10);
		pushAddress(result);
		break;
	}
/*end[PLATFORM_TYPE_BARE_METAL]*/

	case Native_com_sun_squawk_Address_add: {
		int offset = popInt();
		Address addr = popAddress();
		pushAddress(Address_add(addr, offset));
		break;
	}

	case Native_com_sun_squawk_Address_addOffset: {
		Offset offset = popWord();
		Address addr = popAddress();
		pushAddress(Address_add(addr, offset));
		break;
	}

	case Native_com_sun_squawk_Address_sub: {
		int offset = popInt();
		Address addr = popAddress();
		pushAddress(Address_sub(addr, offset));
		break;
	}

	case Native_com_sun_squawk_Address_subOffset: {
		Offset offset = popWord();
		Address addr = popAddress();
		pushAddress(Address_sub(addr, offset));
		break;
	}

	case Native_com_sun_squawk_Address_and: {
		UWord word = popWord();
		UWord addr = (UWord)popAddress();
		pushAddress((Address)(addr & word));
		break;
	}

	case Native_com_sun_squawk_Address_or: {
		UWord word = popWord();
		UWord addr = (UWord)popAddress();
		pushAddress((Address)(addr | word));
		break;
	}

	case Native_com_sun_squawk_Address_diff: {
		Address addr2 = popAddress();
		Address addr1 = popAddress();
		pushWord(Address_diff(addr1, addr2));
		break;
	}

	case Native_com_sun_squawk_Address_roundUp: {
		int alignment = popInt();
		UWord addr = (UWord)popAddress();
		pushAddress((Address)roundUp(addr, alignment));
		break;
	}

	case Native_com_sun_squawk_Address_roundUpToWord: {
		UWord addr = (UWord)popAddress();
		pushAddress((Address)roundUpToWord(addr));
		break;
	}

	case Native_com_sun_squawk_Address_roundDown: {
		int alignment = popInt();
		UWord addr = (UWord)popAddress();
		pushAddress((Address)roundDown(addr, alignment));
		break;
	}

	case Native_com_sun_squawk_Address_roundDownToWord: {
		UWord addr = (UWord)popAddress();
		pushAddress((Address)roundDownToWord(addr));
		break;
	}

	case Native_com_sun_squawk_Address_isZero: {
		Address addr = popAddress();
		pushInt(addr == 0);
		break;
	}

	case Native_com_sun_squawk_Address_isMax: {
		Address addr = popAddress();
		pushInt(addr == ADDRESS_MAX);
		break;
	}

	case Native_com_sun_squawk_Address_zero: {
		pushAddress(0);
		break;
	}

	case Native_com_sun_squawk_Address_max: {
		pushAddress(ADDRESS_MAX);
		break;
	}

	case Native_com_sun_squawk_Address_toUWord: {
		if (TYPEMAP) {
			Address value = popAddress();
			pushWord((UWord)value);
		}
		break;
	}

	case Native_com_sun_squawk_Address_toObject:
	case Native_com_sun_squawk_Address_fromObject: {
		break;
	}

	case Native_com_sun_squawk_Address_eq: {
		Address addr2 = popAddress();
		Address addr1 = popAddress();
		pushInt(addr1 == addr2);
		break;
	}

	case Native_com_sun_squawk_Address_ne: {
		Address addr2 = popAddress();
		Address addr1 = popAddress();
		pushInt(addr1 != addr2);
		break;
	}

	case Native_com_sun_squawk_Address_lo: {
		Address addr2 = popAddress();
		Address addr1 = popAddress();
		pushInt(lo(addr1, addr2));
		break;
	}

	case Native_com_sun_squawk_Address_loeq: {
		Address addr2 = popAddress();
		Address addr1 = popAddress();
		pushInt(loeq(addr1, addr2));
		break;
	}

	case Native_com_sun_squawk_Address_hi: {
		Address addr2 = popAddress();
		Address addr1 = popAddress();
		pushInt(hi(addr1, addr2));
		break;
	}

	case Native_com_sun_squawk_Address_hieq: {
		Address addr2 = popAddress();
		Address addr1 = popAddress();
		pushInt(hieq(addr1, addr2));
		break;
	}

/*if[TYPEMAP]*/
	case Native_com_sun_squawk_NativeUnsafe_setType: {
		int size = popInt();
		char type = (char)popInt();
		Address ea = popAddress();
		setType(ea, type, size);
		break;
	}

	case Native_com_sun_squawk_NativeUnsafe_setArrayTypes: {
		int length = popInt();
		int componentSize = popInt();
		char componentType = (char)popInt();
		Address ea = popAddress();
		while (length-- != 0) {
			setType(ea, componentType, componentSize);
			ea = Address_add(ea, componentSize);
		}
		break;
	}

	case Native_com_sun_squawk_NativeUnsafe_getType: {
		Address ea = popAddress();
		pushInt(getType(ea));
		break;
	}

	case Native_com_sun_squawk_NativeUnsafe_copyTypes: {
		int length = popInt();
		Address dst = popAddress();
		Address src = popAddress();
		copyTypes(src, dst, length);
		break;
	}
/*end[TYPEMAP]*/

	case Native_com_sun_squawk_NativeUnsafe_compareAndSwapInt: {
		int value = popInt();
		int expected = popInt();
		Address obj = popAddress();
		int res = sys_compare_and_swap(obj, expected, value);
		pushInt(res);
		break;
	}

/*if[MICROBLAZE_BUILD]*/
	case Native_com_sun_squawk_NativeUnsafe_sysGlobalMemoryProtection: {
		sysGlobalMemoryProtection();
		break;
	}
/*end[MICROBLAZE_BUILD]*/

	case Native_com_sun_squawk_VM_allocate: {
		int     alth   = popInt();
		Address klass  = popAddress();
		int     size   = popInt();
		Address res    = allocate(size, klass, alth);
		pushAddress(res);
		break;
	}

		/* static void copyBytes(Object src, int srcPos, Object dst, int dstPos, int length, boolean nvmDst);*/
	case Native_com_sun_squawk_VM_copyBytes: {
		int     nvmDst   = popInt();
		int     length   = popInt();
		int     dstPos   = popInt();
		Address dst      = popAddress();
		int     srcPos   = popInt();
		Address src      = popAddress();
		assumeInterp(src != NULL);
		assumeInterp(dst != NULL);
		assumeInterp(srcPos >= 0);
		assumeInterp(dstPos >= 0);
		assumeInterp(length >= 0);
		copyBytes(src, srcPos, dst, dstPos, length, nvmDst);
		break;
	}

		/* static void setBytes(Address src, byte value, int length); */
	case Native_com_sun_squawk_VM_setBytes: {
		int     length   = popInt();
		int     value    = popInt();
		Address dst      = popAddress();
		assumeInterp(dst != NULL);
		assumeInterp(length >= 0);
		memset(dst, value, length);
		break;
	}

	case Native_com_sun_squawk_VM_zeroWords: {
		UWordAddress end   = (UWordAddress)popAddress();
		UWordAddress start = (UWordAddress)popAddress();
		zeroWords(start, end);
		break;
	}

	case Native_com_sun_squawk_VM_deadbeef: {
		UWordAddress end   = (UWordAddress)popAddress();
		UWordAddress start = (UWordAddress)popAddress();
		if (ASSUME || TYPEMAP) {
			while (start < end) {
				if (ASSUME) {
					*start = DEADBEEF;
				}
				setType(start, AddressType_UNDEFINED, HDR_BYTES_PER_WORD);
				start++;
			}
		}
		break;
	}

	case Native_com_sun_squawk_VM_getFP: {
		pushAddress(fp_g);
		break;
	}

	case Native_com_sun_squawk_VM_getMP: {
		Address afp = popAddress();
		pushAddress(getObject(afp, FP_method));
		break;
	}

	case Native_com_sun_squawk_VM_getPreviousFP: {
		Address afp = popAddress();
		pushAddress(getObject(afp, FP_returnFP));
		break;
	}

	case Native_com_sun_squawk_VM_getPreviousIP: {
		Address afp = popAddress();
		pushAddress(getObject(afp, FP_returnIP));
		break;
	}

	case Native_com_sun_squawk_VM_setPreviousFP: {
		Address pfp = popAddress();
		Address afp = popAddress();
		setObject(afp, FP_returnFP, pfp);
		break;
	}

	case Native_com_sun_squawk_VM_setPreviousIP: {
		Address pip = popAddress();
		Address afp = popAddress();
		assumeInterp(inCode(ip_g));
		setObject(afp, FP_returnIP, pip);
		break;
	}

	case Native_com_sun_squawk_VM_getGlobalOopCount: {
		pushInt(GLOBAL_OOP_COUNT);
		break;
	}

	case Native_com_sun_squawk_VM_getGlobalInt: {
		int index = popInt();
		assumeInterp(index < GLOBAL_INT_COUNT);
		pushInt(Ints_g[index]);
		break;
	}

	case Native_com_sun_squawk_VM_getGlobalAddr: {
		int index = popInt();
		assumeInterp(index < GLOBAL_ADDR_COUNT);
		pushAddress(Addrs_g[index]);
		break;
	}

	case Native_com_sun_squawk_VM_getGlobalOop: {
		int index = popInt();
		assumeInterp(index < GLOBAL_OOP_COUNT);
		pushAddress(Oops_g[index]);
		break;
	}

	case Native_com_sun_squawk_VM_getGlobalOopTable: {
		pushAddress(Oops_g);
		break;
	}

	case Native_com_sun_squawk_VM_setGlobalInt: {
		int index  = popInt();
		int value = popInt();
		assumeInterp(index < GLOBAL_INT_COUNT);
		Ints_g[index] = (int)value;
		break;
	}

	case Native_com_sun_squawk_VM_setGlobalAddr: {
		int index  = popInt();
		Address value = popAddress();
		assumeInterp(index < GLOBAL_ADDR_COUNT);
		Addrs_g[index] = value;
		break;
	}

	case Native_com_sun_squawk_VM_setGlobalOop: {
		int index  = popInt();
		Address value = popAddress();
		assumeInterp(index < GLOBAL_OOP_COUNT);
		Oops_g[index] = value;
		break;
	}

	case Native_com_sun_squawk_VM_lcmp: {
		call(com_sun_squawk_VM__lcmp);
		break;
	}

	case Native_com_sun_squawk_VM_callStaticNoParm: {
		int     slot = popInt();
		Address cls  = popAddress();
		call(getStaticMethod(cls, slot));
		break;
	}

	case Native_com_sun_squawk_VM_callStaticOneParm: {
		Address parm = popAddress();
		int     slot = popInt();
		Address cls  = popAddress();
		pushAddress(parm);
		call(getStaticMethod(cls, slot));
		break;
	}

/*if[TYPEMAP]*/
	case Native_com_sun_squawk_VM_hashcode: {
		pushInt((int)popAddress());
		break;
	}
	case Native_com_sun_squawk_VM_asKlass: {
		break;
	}
/*else[TYPEMAP]*/
//		  case Native_com_sun_squawk_VM_hashcode:
//		  case Native_com_sun_squawk_VM_asKlass: {
//			  break;
//		  }
/*end[TYPEMAP]*/

	case Native_com_sun_squawk_VM_fatalVMError: {
		fatalInterpreterError("VM.fatalVMError");
		break;
	}

	case Native_com_sun_squawk_VM_getBranchCount: {
		pushLong(getBranchCount());
		break;
	}

/*if[FINALIZATION]*/
	case Native_com_sun_squawk_VM_finalize: {
		iparm_g = MethodOffsets_virtual_java_lang_Object_finalize;
		do_invokevirtual();
		break;
	}
/*end[FINALIZATION]*/

/*if[KERNEL_SQUAWK]*/
	case Native_com_sun_squawk_VM_isInKernel: {
		pushInt(inKernelMode());
		break;
	}
/*end[KERNEL_SQUAWK]*/

	case Native_com_sun_squawk_VM_threadSwitch: {
		if (com_sun_squawk_VMThread_currentThread !=
		    com_sun_squawk_VMThread_otherThread) { /* this actually happens in tight producer/consumer loops */
			threadSwitch(com_sun_squawk_ServiceOperation_NONE);
		}
		break;
	}

	case Native_com_sun_squawk_VM_executeCIO: {
		Address o2  = popAddress();
		Address o1  = popAddress();
		int i6      = popInt();
		int i5      = popInt();
		int i4      = popInt();
		int i3      = popInt();
		int i2      = popInt();
		int i1      = popInt();
		int channel = popInt();
		int op      = popInt();
		int context = popInt();
		executeCIO(context, op, channel, i1, i2, i3, i4, i5, i6, o1, o2);
		break;
	}

/*if[ENABLE_ISOLATE_MIGRATION]*/
	case Native_com_sun_squawk_VM_executeCOG: {
		Address o2  = popAddress();
		Address o1  = popAddress();
		com_sun_squawk_ServiceOperation_o1 = o1;
		com_sun_squawk_ServiceOperation_o2 = o2;
		if (TRACE)
			printStackTracePrim(-1, ip_g, fp_g, "COPY_OBJECT_GRAPH", null);
		threadSwitchFor(com_sun_squawk_ServiceOperation_COPY_OBJECT_GRAPH);
		break;
	}
/*end[ENABLE_ISOLATE_MIGRATION]*/

	case Native_com_sun_squawk_VM_executeGC: {
		boolean forceFullGC = popInt();
		com_sun_squawk_ServiceOperation_i1 = forceFullGC;
		if (TRACE)
			printStackTracePrim(-1, ip_g, fp_g, "GARBAGE_COLLECT", null);
		threadSwitchFor(com_sun_squawk_ServiceOperation_GARBAGE_COLLECT);
		break;
	}

	case Native_com_sun_squawk_VM_serviceResult: {
		int res = com_sun_squawk_ServiceOperation_result;
		com_sun_squawk_ServiceOperation_result = 0xDEADBEEF;
		pushInt(res);
		break;
	}

	case Native_com_sun_squawk_VM_addressResult: {
		Address res = com_sun_squawk_ServiceOperation_addressResult;
		com_sun_squawk_ServiceOperation_addressResult = null;
		pushAddress(res);
		break;
	}

	case Native_com_sun_squawk_ServiceOperation_cioExecute: {
		void cioExecute(void);
		cioExecute();
		break;
	}

	case Native_com_sun_squawk_VM_isBigEndian: {
		pushInt(PLATFORM_BIG_ENDIAN);
		break;
	}

/*if[GC_com.sun.squawk.CheneyCollector]*/
	case Native_com_sun_squawk_CheneyCollector_memoryProtect: {
		cheneyEndMemoryProtect   = popAddress();
		cheneyStartMemoryProtect = popAddress();
/*fprintf(stderr, "*** cheneyStartMemoryProtect=%d, cheneyEndMemoryProtect=%d\n", cheneyStartMemoryProtect, cheneyEndMemoryProtect);*/
		break;
	}
/*end[GC_com.sun.squawk.CheneyCollector]*/

	case Native_com_sun_squawk_VM_addToClassStateCache: {
		Address state = popAddress();
		Address klass = popAddress();
		addClassState(klass, state);
		break;
	}

	case Native_com_sun_squawk_VM_invalidateClassStateCache: {
		pushInt(invalidateClassStateCache());
		break;
	}

	case Native_com_sun_squawk_VM_removeVirtualMonitorObject: {
		Address res = null;

		if (pendingMonitorStackPointer_g > 0) {
			res = pendingMonitors_g[--pendingMonitorStackPointer_g];
			pendingMonitors_g[pendingMonitorStackPointer_g] = null;
		}
		pushAddress(res);
		break;
	}

	case Native_com_sun_squawk_VM_hasVirtualMonitorObject: {
		Address obj = popAddress();
		boolean res = false;
		int i;
		for (i = 0 ; i < pendingMonitorStackPointer_g ; i++) {
			if (pendingMonitors_g[i] == obj) {
				res = true;
				break;
			}
		}
		pushInt(res);
		break;
	}

	case Native_com_sun_squawk_VM_initializeLiterals: {
		void initializeLiterals();
		initializeLiterals();
		break;
	}

/*if[FLOATS]*/
	case Native_com_sun_squawk_VM_doubleToLongBits:
	case Native_com_sun_squawk_VM_floatToIntBits:
	case Native_com_sun_squawk_VM_longBitsToDouble:
	case Native_com_sun_squawk_VM_intBitsToFloat: {
		/* simply leave bits on the stack: */
		break;
	}

	case Native_com_sun_squawk_VM_math: {
		jlong value2 = popLong();
		jlong value1 = popLong();
		int op = popInt();
		jlong res = math(op, value1, value2);
		pushLong(res);
		break;
	}
/*end[FLOATS]*/

/*if[GC2C]*/
	case Native_com_sun_squawk_GarbageCollector_hasNativeImplementation: {
		pushInt(true);
		break;
	}

	case Native_com_sun_squawk_GarbageCollector_collectGarbageInC: {
		int forceFullGC = popInt();
		Address allocTop = popAddress();
		Address collector = popAddress();
		pushInt(collectGarbage(collector, allocTop, forceFullGC));
		break;
	}

/*else[GC2C]*/
//		case Native_com_sun_squawk_GarbageCollector_hasNativeImplementation: {
//			pushInt(false);
//			break;
//		}
/*end[GC2C]*/

/*if[GC2C]*/
/*if[ENABLE_ISOLATE_MIGRATION]*/
	case Native_com_sun_squawk_GarbageCollector_copyObjectGraphInC: {
		Address allocTop = popAddress();
		Address cb = popAddress();
		Address object = popAddress();
		Address collector = popAddress();
		pushAddress(copyObjectGraph(collector, object, cb, allocTop));
		break;
	}
/*end[ENABLE_ISOLATE_MIGRATION]*/
/*end[GC2C]*/

/*if[LISP2_BITMAP]*/
	case Native_com_sun_squawk_Lisp2Bitmap_clearBitFor: {
		Address ea = popAddress();
		clearBitFor(ea);
		break;
	}

	case Native_com_sun_squawk_Lisp2Bitmap_setBitsFor: {
		Address end = popAddress();
		Address start = popAddress();
		setBitsFor(start, end);
		break;
	}

	case Native_com_sun_squawk_Lisp2Bitmap_clearBitsFor: {
		Address end = popAddress();
		Address start = popAddress();
		clearBitsFor(start, end);
		break;
	}

	case Native_com_sun_squawk_Lisp2Bitmap_getAddressForBitmapWord: {
		Address bitmapWordAddress = popAddress();
		pushAddress(getAddressForBitmapWord(bitmapWordAddress));
		break;
	}

	case Native_com_sun_squawk_Lisp2Bitmap_getAddressOfBitmapWordFor: {
		Address ea = popAddress();
		pushAddress(getAddressOfBitmapWordFor(ea));
		break;
	}

	case Native_com_sun_squawk_Lisp2Bitmap_setBitFor: {
		Address ea = popAddress();
		setBitFor(ea);
		break;
	}

	case Native_com_sun_squawk_Lisp2Bitmap_testAndSetBitFor: {
		Address ea = popAddress();
		pushInt(testAndSetBitFor(ea));
		break;
	}

	case Native_com_sun_squawk_Lisp2Bitmap_testBitFor: {
		Address ea = popAddress();
		pushInt(testBitFor(ea));
		break;
	}

	case Native_com_sun_squawk_Lisp2Bitmap_initialize: {
		Address objectMemoryStart = popAddress();
		int size = popInt();
		Address start = popAddress();
		bitmapInitialize(start, size, objectMemoryStart);
		break;
	}

	case Native_com_sun_squawk_Lisp2Bitmap_iterate: {
		pushAddress(bitmapIterate());
		break;
	}

/*end[LISP2_BITMAP]*/

/*if[KERNEL_SQUAWK]*/
	case Native_com_sun_squawk_VM_sendInterrupt: {
		int interrupt = popInt();
		void os_sendInterrupt(int);
		os_sendInterrupt(interrupt);
		break;
	}

	case Native_com_sun_squawk_VM_setupInterrupt: {
		Address handler = popAddress();
		int interrupt = popInt();
		void os_setupInterrupt(int, Address);
		os_setupInterrupt(interrupt, handler);
		break;
	}

	case Native_com_sun_squawk_VM_setupAlarmInterval: {
		int period = popInt();
		int start = popInt();
		void os_setupAlarmInterval(int, int);
		os_setupAlarmInterval(start, period);
		break;
	}

	case Native_com_sun_squawk_VM_getInterruptStatus: {
		int id = popInt();
		int interrupt = popInt();
		jlong os_getInterruptStatus(int, int);
		pushLong(os_getInterruptStatus(interrupt, id));
		break;
	}
/*end[KERNEL_SQUAWK]*/

	default: {
		/*fprintf(stderr, "*** Undefined native method: *** %d\n", iparm_g);*/
		pushInt(iparm_g);
		call(com_sun_squawk_VM_undefinedNativeMethod);
		break;
	}
	}
}

/**
 * invokenative.
 *
 * Java Stack: [[... arg2], arg1] -> [VALUE]
 * <p>
 */
/*MAC*/ void do_invokenative() {
/*if[MACROIZE]*/
	goto invokenativestart;
/*else[MACROIZE]*/
//	invokenativemain();
/*end[MACROIZE]*/
}

/*-----------------------------------------------------------------------*\
 *                             ALU instructions                          *
 \*-----------------------------------------------------------------------*/

/**
 * Adds two integer values.
 *
 * <p>
 * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1+VALUE2
 * <p>
 */
/*MAC*/ void do_add_i() {
		int r = popInt();
		int l = popInt();
		pushInt(l+r);
}

/**
 * Adds long integer values.
 *
 * <p>
 * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1+VALUE2
 * <p>
 */
/*MAC*/ void do_add_l() {
	jlong r = popLong();
	jlong l = popLong();
	pushLong(l+r);
}

/*if[FLOATS]*/
/**
 * Adds two float values.
 *
 * <p>
 * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1+VALUE2
 * <p>
 */
/*MAC*/ void do_add_f() {
	int r = popInt();
	int l = popInt();
	pushInt(addf(l, r));
}

/**
 * Adds two double values.
 *
 * <p>
 * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1+VALUE2
 * <p>
 */
/*MAC*/ void do_add_d() {
	jlong r = popLong();
	jlong l = popLong();
	pushLong(addd(l, r));
}
/*end[FLOATS]*/

/**
 * Subtracts two integer values.
 *
 * <p>
 * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1-VALUE2
 * <p>
 */
/*MAC*/ void do_sub_i() {
	int r = popInt();
	int l = popInt();
	pushInt(l-r);
}

/**
 * Subtracts two long values.
 *
 * <p>
 * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1-VALUE2
 * <p>
 */
/*MAC*/ void do_sub_l() {
	jlong r = popLong();
	jlong l = popLong();
	pushLong(l-r);
}

/*if[FLOATS]*/
/**
 * Subtracts two floats values.
 *
 * <p>
 * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1-VALUE2
 * <p>
 */
/*MAC*/ void do_sub_f() {
	int r = popInt();
	int l = popInt();
	pushInt(subf(l, r));
}

/**
 * Subtracts two double values.
 *
 * <p>
 * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1-VALUE2
 * <p>
 */
/*MAC*/ void do_sub_d() {
	jlong r = popLong();
	jlong l = popLong();
	pushLong(subd(l, r));
}
/*end[FLOATS]*/

/**
 * Logically ANDs two integer values.
 *
 * <p>
 * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1&VALUE2
 * <p>
 */
/*MAC*/ void do_and_i() {
	int r = popInt();
	int l = popInt();
	pushInt(l&r);
}

/**
 * Logically ANDs two long values.
 *
 * <p>
 * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1&VALUE2
 * <p>
 */
/*MAC*/ void do_and_l() {
	jlong r = popLong();
	jlong l = popLong();
	pushLong(l&r);
}

/**
 * Logically ORs two integer values.
 *
 * <p>
 * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1|VALUE2
 * <p>
 */
/*MAC*/ void do_or_i() {
	int r = popInt();
	int l = popInt();
	pushInt(l|r);
}

/**
 * Logically ORs two long values.
 *
 * <p>
 * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1|VALUE2
 * <p>
 */
/*MAC*/ void do_or_l() {
	jlong r = popLong();
	jlong l = popLong();
	pushLong(l|r);
}

/**
 * Logically XORs two integer values.
 *
 * <p>
 * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1^VALUE2
 * <p>
 */
/*MAC*/ void do_xor_i() {
	int r = popInt();
	int l = popInt();
	pushInt(l^r);
}

/**
 * Logically XORs two long values.
 *
 * <p>
 * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1^VALUE2
 * <p>
 */
/*MAC*/ void do_xor_l() {
	jlong r = popLong();
	jlong l = popLong();
	pushLong(l^r);
}

/**
 * Signed left shifts an integer value.
 *
 * <p>
 * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1<<(VALUE2&1f)
 * <p>
 */
/*MAC*/ void do_shl_i() {
	int r = popInt();
	int l = popInt();
	pushInt(sll(l, r));
}

/**
 * Signed left shifts a long value.
 *
 * <p>
 * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1<<(VALUE2&1f)
 * <p>
 */
/*MAC*/ void do_shl_l() {
	int   r = popInt();
	jlong l = popLong();
	pushLong(slll(l, r));
}

/**
 * Right shifts an integer value.
 *
 * <p>
 * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1>>(VALUE2&1f)
 * <p>
 */
/*MAC*/ void do_shr_i() {
	int r = popInt();
	int l = popInt();
	pushInt(sra(l, r));
}

/**
 * Right shifts a long value.
 *
 * <p>
 * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1>>(VALUE2&1f)
 * <p>
 */
/*MAC*/ void do_shr_l() {
	int   r = popInt();
	jlong l = popLong();
	pushLong(sral(l, r));
}

/**
 * Unsigned right shifts an integer value.
 *
 * <p>
 * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1>>>(VALUE2&1f)
 * <p>
 */
/*MAC*/ void do_ushr_i() {
	int r = popInt();
	int l = popInt();
	pushInt(srl(l, r));
}

/**
 * Unsigned right shifts a long value.
 *
 * <p>
 * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1>>>(VALUE2&1f)
 * <p>
 */
/*MAC*/ void do_ushr_l() {
	int r = popInt();
	jlong l = popLong();
	pushLong(srll(l, r));
}

/**
 * Multiplies two values.
 *
 * <p>
 * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1*VALUE2
 * <p>
 */
/*MAC*/ void do_mul_i() {
	int r = popInt();
	int l = popInt();
/*
  if (l != 0 && r > (java_lang_Integer_MAX_VALUE/l)) {
  fatalInterpreterError("int mult overflow");
  }
*/
	pushInt(l*r);
}

/**
 * Multiplies two values.
 *
 * <p>
 * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1*VALUE2
 * <p>
 */
/*MAC*/ void do_mul_l() {
	jlong r = popLong();
	jlong l = popLong();
/*
  if (l != 0 && r > (java_lang_Long_MAX_VALUE/l)) {
  fatalInterpreterError("int mult overflow");
  }
*/
	pushLong(l*r);
}

/*if[FLOATS]*/
/**
 * Multiplies two values.
 *
 * <p>
 * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1*VALUE2
 * <p>
 */
/*MAC*/ void do_mul_f() {
	int r = popInt();
	int l = popInt();
	pushInt(mulf(l, r));
}

/**
 * Multiplies two values.
 *
 * <p>
 * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1*VALUE2
 * <p>
 */
/*MAC*/ void do_mul_d() {
	jlong r = popLong();
	jlong l = popLong();
	pushLong(muld(l, r));
}
/*end[FLOATS]*/

/**
 * Divides a value.
 *
 * <p>
 * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1/VALUE2
 * <p>
 */
/*MAC*/ void do_div_i() {
	int r = popInt();
	int l = popInt();
	checkReferenceSlots();
	if (r == 0) {
		resetStackPointerIfRevParms();
		call(com_sun_squawk_VM_arithmeticException);
	} else if (l == 0x80000000 && r == -1) {
		pushInt(l);
	} else {
		pushInt(l / r);
	}
}

/**
 * Divides a value.
 *
 * <p>
 * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1/VALUE2
 * <p>
 */
/*MAC*/ void do_div_l() {
	jlong r = popLong();
	jlong l = popLong();
	checkReferenceSlots();
	if (r == 0) {
		resetStackPointerIfRevParms();
		call(com_sun_squawk_VM_arithmeticException);
/*if[SQUAWK_64]*/
	} else if (r == -1L && l == 0x8000000000000000L) {
		/*
		 * On the AMD64/gcc platform, a SIGFPE is generated when the dividend is
		 * the negative value of largest possible magnitude for the 'long' type
		 * and the divisor is -1. This in turn causes the following TCK test to fail:
		 *
		 *   javasoft/sqe/tests/vm/instr/ldiv/ldiv002/ldiv00201m1/ldiv00201m1
		 *
		 * The VM spec states (6.4 ldiv) that in this special case, the dividend is returned.
		 */
		pushLong(l);
/*end[SQUAWK_64]*/
	} else {
		pushLong(l / r);
	}
}

/*if[FLOATS]*/
/**
 * Divides a value.
 *
 * <p>
 * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1/VALUE2
 * <p>
 */
/*MAC*/ void do_div_f() {
	int r = popInt();
	int l = popInt();
	pushInt(divf(l, r));
}

/**
 * Divides a value.
 *
 * <p>
 * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1/VALUE2
 * <p>
 */
/*MAC*/ void do_div_d() {
	jlong r = popLong();
	jlong l = popLong();
	pushLong(divd(l, r));
}
/*end[FLOATS]*/

/**
 * Rem a value.
 *
 * <p>
 * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1%VALUE2
 * <p>
 */
/*MAC*/ void do_rem_i() {
	int r = popInt();
	int l = popInt();
	checkReferenceSlots();
	if (r == 0) {
		resetStackPointerIfRevParms();
		call(com_sun_squawk_VM_arithmeticException);
	} else if (l == 0x80000000 && r == -1) {
		pushInt(l % 1);
	} else {
		pushInt(l % r);
	}
}

/**
 * Rem a value.
 *
 * <p>
 * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1%VALUE2
 * <p>
 */
/*MAC*/ void do_rem_l() {
	jlong r = popLong();
	jlong l = popLong();
	checkReferenceSlots();
	if (r == 0) {
		resetStackPointerIfRevParms();
		call(com_sun_squawk_VM_arithmeticException);
/*if[SQUAWK_64]*/
	} else if (r == -1L && l == 0x8000000000000000L) {
		/*
		 * On the AMD64/gcc platform, a SIGFPE is generated when the dividend is
		 * the negative value of largest possible magnitude for the 'long' type
		 * and the divisor is -1. This in turns causes the following TCK test to fail:
		 *
		 *   javasoft/sqe/tests/vm/instr/lrem/lrem001/lrem00101m1
		 *
		 * The VM spec states (6.4 ldiv) that in this special case, 0 is returned.
		 */
		pushLong(0);
/*end[SQUAWK_64]*/
	} else {
		pushLong(l % r);
	}
}

/*if[FLOATS]*/
/**
 * Rem a value.
 *
 * <p>
 * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1%VALUE2
 * <p>
 */
/*MAC*/ void do_rem_f() {
	int r = popInt();
	int l = popInt();
	pushInt(remf(l, r));
}

/**
 * Rem a value.
 *
 * <p>
 * Java Stack: ..., VALUE1, VALUE2 -> ..., VALUE1%VALUE2
 * <p>
 */
/*MAC*/ void do_rem_d() {
	jlong r = popLong();
	jlong l = popLong();
	pushLong(remd(l, r));
}
/*end[FLOATS]*/

/**
 * Negates a value.
 *
 * <p>
 * Java Stack: ..., VALUE -> ..., -VALUE1
 * <p>
 */
/*MAC*/ void do_neg_i() {
	/*
	 * Note: Due to a bug in the Solaris cc compiler when both
	 *       -o3 and -mac are enabled, this was changed from:
	 *
	 *     int r = popInt();
	 *     pushInt(0 - r);
	 */
	int r = 0 - popInt();
	pushInt(r);
}

/**
 * Negates a value.
 *
 * <p>
 * Java Stack: ..., VALUE -> ..., -VALUE1
 * <p>
 */
/*MAC*/ void do_neg_l() {
	jlong r = 0 - popLong();
	pushLong(r);
}

/*if[FLOATS]*/
/**
 * Negates a value.
 *
 * <p>
 * Java Stack: ..., VALUE -> ..., -VALUE1
 * <p>
 */
/*MAC*/ void do_neg_f() {
	int r = popInt();
	pushInt(negf(r));
}

/**
 * Negates a value.
 *
 * <p>
 * Java Stack: ..., VALUE -> ..., -VALUE1
 * <p>
 */
/*MAC*/ void do_neg_d() {
	jlong r = popLong();
	pushLong(negd(r));
}

/**
 * Compare two floats.
 *
 * <p>
 * Java Stack: ..., VALUE1, VALUE2 -> ..., int
 * <p>
 */
/*MAC*/ void do_fcmpl() {
	float r = ib2f(popInt());
	float l = ib2f(popInt());
	int result = -1;

	if (l >  r) {
		result = 1;
	} else if (l == r) {
		result = 0;
	}

	pushInt(result);
}

/**
 * Compare two floats.
 *
 * <p>
 * Java Stack: ..., VALUE1, VALUE2 -> ..., int
 * <p>
 */
/*MAC*/ void do_fcmpg() {
	float r = ib2f(popInt());
	float l = ib2f(popInt());
	int result = 1;

	if (l <  r) {
		result = -1;
	} else if (l == r) {
		result = 0;
	}

	pushInt(result);
}

/**
 * Compare two doubles.
 *
 * <p>
 * Java Stack: ..., VALUE1, VALUE2 -> ..., int
 * <p>
 */
/*MAC*/ void do_dcmpl() {
	double r = lb2d(popLong());
	double l = lb2d(popLong());
	int result = -1;

	if (l > r) {
		result = 1;
	} else if (l == r) {
		result = 0;
	}

	pushInt(result);
}

/**
 * Compare two doubles.
 *
 * <p>
 * Java Stack: ..., VALUE1, VALUE2 -> ..., int
 * <p>
 */
/*MAC*/ void do_dcmpg() {
	double r = lb2d(popLong());
	double l = lb2d(popLong());
	int result = 1;

	if (l < r) {
		result = -1;
	} else if (l == r) {
		result = 0;
	}

	pushInt(result);
}

/*end[FLOATS]*/


/*-----------------------------------------------------------------------*\
 *                              Convertions                              *
 \*-----------------------------------------------------------------------*/

/**
 * Convert int to byte.
 *
 * <p>
 * Java Stack: ..., INT -> ..., INT
 * <p>
 */
/*MAC*/ void do_i2b() {
	int r = popInt();
	pushInt((byte)r);
}

/**
 * Convert int to short.
 *
 * <p>
 * Java Stack: ..., INT -> ..., INT
 * <p>
 */
/*MAC*/ void do_i2s() {
	int r = popInt();
	pushInt((short)r);
}

/**
 * Convert int to char.
 *
 * <p>
 * Java Stack: ..., INT -> ..., INT
 * <p>
 */
/*MAC*/ void do_i2c() {
	int r = popInt();
	pushInt((unsigned short)r);
}

/**
 * Convert long to int.
 *
 * <p>
 * Java Stack: ..., LONG -> ..., INT
 * <p>
 */
/*MAC*/ void do_l2i() {
	jlong r = popLong();
	pushInt((int)r);
}

/**
 * Convert int to long.
 *
 * <p>
 * Java Stack: ..., INT -> ..., LONG
 * <p>
 */
/*MAC*/ void do_i2l() {
	int r = popInt();
	pushLong(r);
}
/*if[FLOATS]*/
/**
 * Convert int to float.
 *
 * <p>
 * Java Stack: ..., INT -> ..., FLOAT
 * <p>
 */
/*MAC*/ void do_i2f() {
	int r = popInt();
	pushInt(i2f(r));
}

/**
 * Convert long to float.
 *
 * <p>
 * Java Stack: ..., LONG -> ..., FLOAT
 * <p>
 */
/*MAC*/ void do_l2f() {
	jlong r = popLong();
	pushInt(l2f(r));
}

/**
 * Convert float to int.
 *
 * <p>
 * Java Stack: ..., FLOAT -> ..., INT
 * <p>
 */
/*MAC*/ void do_f2i() {
	int r = popInt();
	pushInt(f2i(r));
}

/**
 * Convert float to long.
 *
 * <p>
 * Java Stack: ..., FLOAT -> ..., LONG
 * <p>
 */
/*MAC*/ void do_f2l() {
	int r = popInt();
	pushLong(f2l(r));
}

/**
 * Convert int to double.
 *
 * <p>
 * Java Stack: ..., INT -> ..., DOUBLE
 * <p>
 */
/*MAC*/ void do_i2d() {
	int r = popInt();
	pushLong(i2d(r));
}

/**
 * Convert long to double.
 *
 * <p>
 * Java Stack: ..., LONG -> ..., DOUBLE
 * <p>
 */
/*MAC*/ void do_l2d() {
	jlong r = popLong();
	pushLong(l2d(r));
}

/**
 * Convert float to double.
 *
 * <p>
 * Java Stack: ..., FLOAT -> ..., DOUBLE
 * <p>
 */
/*MAC*/ void do_f2d() {
	int r = popInt();
	pushLong(f2d(r));
}

/**
 * Convert double to int.
 *
 * <p>
 * Java Stack: ..., DOUBLE -> ..., INT
 * <p>
 */
/*MAC*/ void do_d2i() {
	jlong r = popLong();
	pushInt(d2i(r));
}

/**
 * Convert double to long.
 *
 * <p>
 * Java Stack: ..., DOUBLE -> ..., LONG
 * <p>
 */
/*MAC*/ void do_d2l() {
	jlong r = popLong();
	pushLong(d2l(r));
}

/**
 * Convert double to float.
 *
 * <p>
 * Java Stack: ..., DOUBLE -> ..., FLOAT
 * <p>
 */
/*MAC*/ void do_d2f() {
	jlong r = popLong();
	pushInt(d2f(r));
}
/*end[FLOATS]*/


/*-----------------------------------------------------------------------*\
 *        Complex instructions implemented with external functions       *
 \*-----------------------------------------------------------------------*/

#if TRACE
/*DEF*/ void PRINTSTACK() {
	Address cls = getClass(exception);
	Address name = com_sun_squawk_Klass_name(cls);
	char buf[1000];
	int pos = getArrayLength(name);
	if (pos >= 991) {
		pos = 990;
	}
	memmove(buf, name, pos);
	buf[pos++] = ':';
	buf[pos++] = ' ';
	pos += printJavaStringBuf(java_lang_Throwable_detailMessage(exception), buf + pos, 999 - pos);
	buf[pos] = 0;
	printStackTracePrim(-1, ip_g, fp_g, buf, null);
}
#else
#define PRINTSTACK() /**/
#endif


/**
 * Throw an exception.
 *
 * <p>
 * Java Stack: OOP -> _
 * <p>
 */
/*MAC*/ void do_throw() {
	if (usingServiceStack()) {
		Address exception = popAddress();
		fprintf(stderr, "do_throw on service stack. current code=%d:\n", com_sun_squawk_ServiceOperation_code);
		assumeInterp(exception == null || ((UWord)getObject(exception, HDR_klass) & HDR_headerTagMask) == 0);
		if (exception != NULL && getClass(exception) != NULL) {
			printJavaStrSafely(com_sun_squawk_Klass_name(getClass(exception)), "class");
			printJavaStrSafely(java_lang_Throwable_detailMessage(exception), "detail message");
		}
		fatalInterpreterError("");
	} else {
		__attribute__((unused)) UWord oldip = (UWord)ip_g;
		Address exception = popAddress();
		nullCheck((Address)exception);
		PRINTSTACK();
		if (com_sun_squawk_ServiceOperation_pendingException != 0) {
			fatalInterpreterError("do_throw with pending exception");
		}
		com_sun_squawk_ServiceOperation_pendingException = exception;
		threadSwitchFor(com_sun_squawk_ServiceOperation_THROW);
	}
}

/**
 * Start an exception handler.
 *
 * <p>
 * Compiler Stack: _ -> OOP
 * <p>
 */
/*MAC*/ void do_catch() {
	Address exception = (Address)com_sun_squawk_ServiceOperation_pendingException;
	assumeInterp(exception != null);
	com_sun_squawk_ServiceOperation_pendingException = 0;
	pushAddress(exception);
}

/**
 * Execute a monitor enter.
 *
 * <p>
 * Java Stack: OOP -> _
 * <p>
 */
/*MAC*/ void do_monitorenter() {
	Address obj = popAddress();
	Address assn;

	nullCheck(obj);
	assumeInterp(((UWord)getObject(obj, HDR_klass) & HDR_headerTagMask) == 0);
	assn = getClassOrAssociation(obj);
	if (unlikely(MONITOR_CACHE_SIZE == 0
	             || associationToKlass(assn) != assn
	             || pendingMonitorStackPointer_g == MONITOR_CACHE_SIZE
	             || !(hi(obj, com_sun_squawk_GC_ramStart)
	                  && loeq(obj, com_sun_squawk_GC_ramEnd)))) {
		pushAddress(obj);
		call(com_sun_squawk_VM_monitorenter);
	} else {
		pendingMonitors_g[pendingMonitorStackPointer_g++] = obj;
	}
}

#ifdef INTERPRETER_STATS
#define updatePendingMonitorAccesses() pendingMonitorAccesses_g++
#define updatePendingMonitorHits() pendingMonitorHits_g++
#else
#define updatePendingMonitorAccesses()
#define updatePendingMonitorHits()
#endif /* INTERPRETER_STATS */

/**
 * Execute a monitor exit.
 *
 * <p>
 * Java Stack: OOP -> _
 * <p>
 */
/*MAC*/ void do_monitorexit() {
	Address obj = popAddress();
	Address assn;

	nullCheck(obj);
	assumeInterp(((UWord)getObject(obj, HDR_klass) & HDR_headerTagMask) == 0);
	assn = getClassOrAssociation(obj);
	updatePendingMonitorAccesses();
	if (unlikely(MONITOR_CACHE_SIZE == 0
	             || associationToKlass(assn) != assn
	             || pendingMonitorStackPointer_g == 0
	             || !(hi(obj, com_sun_squawk_GC_ramStart)
	                  && loeq(obj, com_sun_squawk_GC_ramEnd)))) {
		pushAddress(obj);
		call(com_sun_squawk_VM_monitorexit);
	} else {
		__attribute__((unused)) Address obj2 =
			pendingMonitors_g[--pendingMonitorStackPointer_g];
		assumeInterp(obj == obj2);
		pendingMonitors_g[pendingMonitorStackPointer_g] = null;
		updatePendingMonitorHits();
	}
}

/**
 * Execute a monitor enter.
 *
 * <p>
 * Java Stack: _ -> _
 * <p>
 */
/*MAC*/ void do_class_monitorenter() {
	pushAddress(getCP());
	do_monitorenter();
}

/**
 * Execute a monitor exit.
 *
 * <p>
 * Java Stack: _ -> _
 * <p>
 */
/*MAC*/ void do_class_monitorexit() {
	pushAddress(getCP());
	do_monitorexit();
}

/**
 * Initialize class if needed.
 *
 * <p>
 * Java Stack: _ -> _
 * <p>
 */
/*MAC*/ void do_class_clinit() {
	checkReferenceSlots();
	if (unlikely(needsInitializing(getCP()))) {
		pushAddress(getCP());
		call(com_sun_squawk_VM_class_clinit);
	}
}

/**
 * Get the length of an array.
 *
 * <p>
 * Java Stack: ..., OOP -> ..., INT
 * <p>
 */
/*MAC*/ void do_arraylength() {
	Address oop = popAddress();
	nullCheck(oop);
	pushInt(getArrayLength(oop));
}

#ifdef INTERPRETER_STATS
#define updateNewHits() com_sun_squawk_GC_newHits++
#else
#define updateNewHits()
#endif /* INTERPRETER_STATS */

/**
 * Allocate an object.
 *
 * <p>
 * Java Stack: ..., CLASS -> ..., OOP
 * <p>
 */
/*MAC*/ void do_new() {
	checkReferenceSlots();
	if (FASTALLOC) {
		Address klass = popAddress();
		/* if the class does not need initialization */
		if (likely(!needsInitializing(klass))) {
/*if[FINALIZATION]*/
			boolean hasFinalizer = false;
			hasFinalizer = (com_sun_squawk_Klass_modifiers(klass) & com_sun_squawk_Modifier_HASFINALIZER) != 0;
			/* if the class does not have a finalizer */
			if (!hasFinalizer) {
/*end[FINALIZATION]*/
				/* Then this inline code will do the work faster */
				int allocSize    = roundUpToWord(com_sun_squawk_Klass_instanceSizeBytes(klass)) + HDR_basicHeaderSize;
				Address oop      = allocateFast(allocSize, klass, -1);
				if (oop != null) {
					pushAddress(oop);
					updateNewHits();
					nextbytecode();
				}
/*if[FINALIZATION]*/
			}
/*end[FINALIZATION]*/
		}
		pushAddress(klass);
	}
	call(com_sun_squawk_VM__new);
}

/**
 * Allocate a new array.
 *
 * <p>
 * Java Stack: SIZE, CLASS -> ..., OOP
 * <p>
 */
/*MAC*/ void do_newarray() {
	checkReferenceSlots();
	if (FASTALLOC) {
		Address klass = popAddress();
		int length    = popInt();
		if (likely(length >= 0)) {
			Address ctype = com_sun_squawk_Klass_componentType(klass);
			int dataSize = getDataSize(ctype);
			int bodySize = length * dataSize;
			if (likely(bodySize >= 0)) {
				int allocSize = roundUpToWord(HDR_arrayHeaderSize + bodySize);
				Address oop   = allocateFast(allocSize, klass, length);
				if (oop != null) {
					pushAddress(oop);
					updateNewHits();
					nextbytecode();
				}
			}
		}
		pushInt(length);
		pushAddress(klass);
	}
	call(com_sun_squawk_VM_newarray);
}

/**
 * Allocate a new array dimension.
 *
 * <p>
 * Java Stack: OOP, SIZE -> ..., OOP
 * <p>
 */
/*MAC*/ void do_newdimension() {
	call(com_sun_squawk_VM_newdimension);
}

/**
 * Instanceof.
 *
 * <p>
 * Java Stack: ..., OOP, CLASS -> ..., INT
 * <p>
 */
/*MAC*/ void do_instanceof() {
	Address klass = popAddress();
	Address obj   = popAddress();
	checkReferenceSlots();
	if (obj == null || klass == null) {
		pushInt(false);
	} else {
		pushInt(VM_instanceof(obj, klass));
	}
}

/**
 * Checkcast.
 *
 * <p>
 * Java Stack: ..., OOP, CLASS -> ..., OOP
 * <p>
 */
/*MAC*/ void do_checkcast() {
	Address klass = popAddress();
	Address obj   = popAddress();
	checkReferenceSlots();
	if (obj != null && !VM_instanceof(obj, klass)) {
		pushAddress(obj);
		pushAddress(klass);
		call(com_sun_squawk_VM_checkcastException);
	} else {
		pushAddress(obj);
	}
}

/**
 * Lookup.
 *
 * <p>
 * Java Stack: KEY, ARRAY -> VALUE
 * <p>
 */
/*MAC*/ void do_lookup_b() {
	Address barray = popAddress();
	int  key = popInt();
	pushInt(VM_lookup_b(key, barray));
}
/*MAC*/ void do_lookup_s() {
	Address sarray = popAddress();
	int  key = popInt();
	pushInt(VM_lookup_s(key, sarray));
}
/*MAC*/ void do_lookup_i() {
	Address iarray = popAddress();
	int  key = popInt();
	pushInt(VM_lookup_i(key, iarray));
}

/**
 * Reserved.
 *
 * <p>
 * Compiler Stack: ... -> ...
 * <p>
 *
 * @param n ignored parameter
 */
/*MAC*/ void do_res(int $n) {
	shouldNotReachHere();
}
