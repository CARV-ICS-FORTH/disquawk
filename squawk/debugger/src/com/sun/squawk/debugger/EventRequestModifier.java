/*
 * Copyright 2004-2008 Sun Microsystems, Inc. All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER
 * 
 * This code is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2
 * only, as published by the Free Software Foundation.
 * 
 * This code is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License version 2 for more details (a copy is
 * included in the LICENSE file that accompanied this code).
 * 
 * You should have received a copy of the GNU General Public License
 * version 2 along with this work; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 * 
 * Please contact Sun Microsystems, Inc., 16 Network Circle, Menlo
 * Park, CA 94025 or visit www.sun.com if you need additional
 * information or have any questions.
 */

package com.sun.squawk.debugger;

import java.io.*;

import com.sun.squawk.debugger.*;
import com.sun.squawk.debugger.DataType.*;
import com.sun.squawk.util.*;
import com.sun.squawk.Debugger;

/**
 * The <code>EventRequestModifier</code> class creates a "filter" for <code>EventRequest</code>
 * objects, so that only events that are matched by the modifiers associated with an event
 * request are sent to the debugger. Modifiers are specified as part of a JDWP
 * EventRequest.Set command.
 *
 */
public abstract class EventRequestModifier {

    public static interface Matcher {
        public boolean matches(ClassMatch modifier, Debugger.Event event);
        public boolean matches(ClassOnly modifier, Debugger.Event event);
        public boolean matches(ExceptionOnly modifier, Debugger.Event event);
        public boolean matches(LocationOnly modifier, Debugger.Event event);
    }

    /**
     * Determines if this modifier matches the event currently being processed by an event manager.
     *
     * @return true if this modifier matches the event
     */
    public abstract boolean matches(Matcher matcher, Debugger.Event event);

    /**
     * A <code>Count</code> modifier limits the requested event to be reported at most
     * once after a given number of occurrences. The event is not reported the first
     * <code>count - 1</code> times this filter is reached. To request a one-off event,
     * call this method with a count of 1.
     * <p>
     * Once the count reaches 0, any subsequent filters in this request are applied.
     * If none of those filters cause the event to be suppressed, the event is reported.
     * Otherwise, the event is not reported. In either case subsequent events are never
     * reported for this request. This modifier can be used with any event kind.
     */
    public static final class Count extends EventRequestModifier {

        private int count;

        /**
         * Creates a Count modifier.
         *
         * @see EventRequestModifier#create
         */
        public Count(PacketInputStream in) throws SDWPException, IOException {
            count = in.readInt("count");
        }

        /**
         * {@inheritDoc}
         */
        public boolean matches(Matcher matcher, Debugger.Event event) {
            return --count == 0;
        }

        /**
         * {@inheritDoc}
         */
        public String toString() {
            return "<MOD_COUNT: count=" + count + ">";
        }
    }

    /**
     * For class prepare event, a <code>ClassOnly</code> modifier restricts the events
     * generated by this request to be the preparation of the given reference type and
     * any subtypes. For other events, restricts the events generated by this request
     * to those whose location is in the given reference type or any of its subtypes.
     * An event will be generated for any location in a reference type that can be safely
     * cast to the given reference type. This modifier can be used with any event kind
     * except class unload, thread start, and thread end.
     */
    public final static class ClassOnly extends EventRequestModifier {

        /**
         * Match acts differently for different event types.
         */
        public final int eventKind;
        public final ReferenceTypeID clazz;

        /**
         * Creates a ClassOnly modifier.
         *
         * @see EventRequestModifier#create
         */
        public ClassOnly(PacketInputStream in, int kind) throws SDWPException, IOException {
            switch (kind) {
                case JDWP.EventKind_CLASS_UNLOAD:
                case JDWP.EventKind_THREAD_START:
                case JDWP.EventKind_THREAD_END:
                    throw new SDWPException(JDWP.Error_INVALID_EVENT_TYPE, "Bad event kind for MOD_CLASS_ONLY: " + kind);
                default:
                    break; // all other kinds OK
            }

            clazz = in.readReferenceTypeID("clazz");
            eventKind = kind;
        }

        /**
         * {@inheritDoc}
         */
        public boolean matches(Matcher matcher, Debugger.Event event) {
            return matcher.matches(this, event);
        }

        /**
         * {@inheritDoc}
         */
        public String toString() {
            return "<MOD_CLASS_ONLY: clazz=" + clazz + ">";
        }
    }

    /**
     * A <code>ClassMatch</code> modifier restricts reported events to those for classes whose
     * name matches a restricted regular expression. For class prepare events, the
     * prepared class name is matched. For class unload events, the unloaded class name is matched.
     * For other events, the class name of the event's location is matched. This modifier can be
     * used with any event kind except thread start and thread end.
     */
    public final static class ClassMatch extends EventRequestModifier {
        public final static int EQUALS      = 1;
        public final static int STARTS_WITH = 2;
        public final static int ENDS_WITH   = 3;
        public final static int CONTAINS    = 4;

        /**
         * The restricted regular expression sent by the debugger
         */
        public final String classPattern;

        /**
         * The string derived from the regular expression to do the matching.
         */
        public final String pattern;

        /**
         * The operation to be performed with <code>pattern</code> to do the match.
         */
        public final int matchKind;

        /**
         * The name to match depends on the event kind.
         */
        public final int eventKind;

        /**
         * If true, this is a ClassExclude modifier, otherwise a ClassMatch modifier.
         */
        public final boolean exclude;

        /**
         * Creates a ClassMatch modifier.
         *
         * @see EventRequestModifier#create
         */
        public ClassMatch(PacketInputStream in, int kind, boolean exclude) throws SDWPException, IOException {
            this.exclude = exclude;
            switch (kind) {
                case JDWP.EventKind_THREAD_START:
                case JDWP.EventKind_THREAD_END:
                    throw new SDWPException(JDWP.Error_INVALID_EVENT_TYPE, "Bad event kind for MOD_CLASS_MATCH: " + kind);
                default:
                    break; // all other kinds OK
            }

            classPattern = in.readString("classPattern");
            String str = classPattern;
            int len = str.length();
            this.eventKind = kind;
            int tmpMatchKind = EQUALS;
            if (len == 0) {
                if (Log.info()) {
                    Log.log("This is odd: debugger wants us to match a class event if the name "
                        + (exclude ? "is" : "is not") + " the empty string. OK.");
                }
            } else {
                if (str.charAt(0) == '*') {
                    if (str.charAt(len-1) == '*') {
                        tmpMatchKind = CONTAINS;
                        str = str.substring(1, len-1);
                    } else {
                        tmpMatchKind = ENDS_WITH;
                        str = str.substring(1);
                    }
                } else if (str.charAt(len-1) == '*') {
                    tmpMatchKind = STARTS_WITH;
                    str = str.substring(0, len-1);
                }
            }
            this.matchKind = tmpMatchKind;
            this.pattern = str;
        }

        /**
         * {@inheritDoc}
         */
        public boolean matches(Matcher matcher, Debugger.Event event) {
            return matcher.matches(this, event);
        }

        /**
         * {@inheritDoc}
         */
        public String toString() {
            return (!exclude ? "<MOD_CLASS_MATCH: " : "<MOD_CLASS_EXCLUDE: ") + classPattern + "\">";
        }
    }

    /**
     * A <code>LocationOnly</code> modifier restricts reported events to those that
     * occur at a given location. This modifier can be used with breakpoint, field
     * access, field modification, step, and exception event kinds.
     */
    public final static class LocationOnly extends EventRequestModifier {

        public final Location location;

        /**
         * Creates a LocationOnly modifier.
         *
         * @see EventRequestModifier#create
         */
        public LocationOnly(PacketInputStream in, int kind) throws SDWPException, IOException {
            switch (kind) {
                case JDWP.EventKind_BREAKPOINT:
                case JDWP.EventKind_FIELD_ACCESS:
                case JDWP.EventKind_FIELD_MODIFICATION:
                case JDWP.EventKind_EXCEPTION:
                    break; // only these event kinds OK
                default:
                    throw new SDWPException(JDWP.Error_INVALID_EVENT_TYPE, "Bad event kind for MOD_LOCATION_ONLY: " + kind);
            }

            location = in.readLocation("loc");
        }

        /**
         * {@inheritDoc}
         */
        public boolean matches(Matcher matcher, Debugger.Event event) {
            return matcher.matches(this, event);
        }

        /**
         * {@inheritDoc}
         */
        public String toString() {
            return "<MOD_LOCATION_ONLY: " + location + ">";
        }
    }

    /**
     * An <code>ExceptionOnly</code> modifier restricts reported exceptions by their
     * class and whether they are caught or uncaught. This modifier can be used with
     * exception event kinds only.
     */
    public final static class ExceptionOnly extends EventRequestModifier {

        public final ReferenceTypeID exceptionOrNull;
        public final boolean caught;
        public final boolean uncaught;

        /**
         * Creates an ExceptionOnly.
         *
         * @see EventRequestModifier#create
         */
        public ExceptionOnly(PacketInputStream in, int kind) throws SDWPException, IOException {
            if (kind != JDWP.EventKind_EXCEPTION) {
                throw new SDWPException(JDWP.Error_INVALID_EVENT_TYPE, "Bad event kind for MOD_EXCEPTION_ONLY: " + kind);
            }

            exceptionOrNull = in.readReferenceTypeID("exceptionOrNull");
            caught = in.readBoolean("caught");
            uncaught = in.readBoolean("uncaught");
        }

        /**
         * {@inheritDoc}
         */
        public boolean matches(Matcher matcher, Debugger.Event event) {
            return matcher.matches(this, event);
        }

        /**
         * {@inheritDoc}
         */
        public String toString() {
            return "<MOD_EXCEPTION_ONLY: exceptionOrNull=" + exceptionOrNull +
                " caught=" + caught + " uncaught=" + uncaught + ">";
        }
    }

    /**
     * A <code>ThreadOnly</code> modifier restricts reported events to those in a
     * given thread. This modifier can be used with any event kind except for class unload.
     */
    public static class ThreadOnly extends EventRequestModifier {

        public final ObjectID threadID;

        /**
         * Creates a ThreadOnly modifier.
         *
         * @see EventRequestModifier#create
         */
        public ThreadOnly(PacketInputStream in, int kind) throws SDWPException, IOException {
            if (kind == JDWP.EventKind_CLASS_UNLOAD) {
                throw new SDWPException(JDWP.Error_INVALID_EVENT_TYPE, "Bad event kind for MOD_THREAD_ONLY: " + kind);
            }
            this.threadID = in.readObjectID("thread");
        }

        /**
         * {@inheritDoc}
         */
        public boolean matches(Matcher matcher, Debugger.Event event) {
            return event.getThreadID().equals(threadID);
        }

        /**
         * {@inheritDoc}
         */
        public String toString() {
            return "<MOD_THREAD_ONLY: threadID=" + threadID + ">";
        }
    }

    /**
     * A <code>Step</code> modifier restricts reported step events to those which satisfy depth
     * and size constraints. This modifier can only be used with single step events.
     */
    public final static class Step extends EventRequestModifier {

        public final ObjectID threadID;
        public final int size;
        public final int depth;

        /**
         * Creates a Step modifier.
         *
         * @see EventRequestModifier#create
         */
        public Step(PacketInputStream in, int kind) throws SDWPException, IOException {
            if (kind != JDWP.EventKind_SINGLE_STEP) {
                throw new SDWPException(JDWP.Error_INVALID_EVENT_TYPE, "Bad event kind for MOD_STEP: " + kind);
            }
            this.threadID = in.readObjectID("thread");
            int size = in.readInt("size");
            this.depth = in.readInt("depth");

            if (size != JDWP.StepSize_LINE) {
                if (Log.info()) {
                    Log.log("warning: only source line stepping is supported");
                }
                size = JDWP.StepSize_LINE;
            }
            this.size = size;
        }

        /**
         * {@inheritDoc}
         */
        public boolean matches(Matcher matcher, Debugger.Event event) {
            return event.getThreadID().equals(threadID);
        }

        /**
         * {@inheritDoc}
         */
        public String toString() {
            return "<MOD_STEP: threadID=" + threadID + ", size=" + this.size + ", depth=" + this.depth + ">";
        }
    }
}
